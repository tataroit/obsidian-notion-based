Всё по разработке

## Development

## Frontend (4)

- [x] ~~Метрики~~
    - ~~**Технические**~~

        ~~Текущий набор метрик **Core Web Vitals** фокусируется на трех аспектах взаимодействия с пользователем: **скорости загрузки страниц сайта, интерактивности и визуальной стабильности**, и включает следующие показатели:~~

        - ~~**Largest Contentful Paint (LCP)** — Скорость загрузки основного контента: измеряет производительность загрузки.~~
        - ~~**First Input Delay (FID)** — Время ожидания до первого взаимодействия с контентом: измеряет интерактивность.~~
        - ~~**Cumulative Layout Shift (CLS)** — Совокупное смещение макета: измеряет визуальную стабильность. Показатель CLS не должен превышать 0,1.~~
        - ~~Есть так же и дополнительные метрики, которые достаточно важны, и косвенно влияют на основные, не но не полностью входят в **Core Web Vitals**~~
            - ~~Например, метрики **Time to First Byte (TTFB)** — Время до первого байта и **First Contentful Paint (FCP)** — Первая отрисовка контента являются критически важными аспектами загрузки и полезны для диагностики проблем с **LCP** (медленное время отклика сервера или ресурсы, блокирующие рендеринг).~~
            - ~~А такие показатели, как **Total Blocking Time (TBT)** — Общее время блокировки и **Time to Interactive (TTI)** — Время до интерактивности, являются крайне важными метриками для выявления и диагностики потенциальных проблем с интерактивностью, которые могут повлиять на **FID**.~~
    - ~~**Бизнес-требования**~~
        - ~~В целом, работаем через метрики, следующим образом:~~
            ~~- В какой-то момент приходят сеошники, аналитик и менеджер, собираемся, конкретизируем и выявляем необходимые целевые показатели: количество посещений, количество заказов, конверсия, средний чек.~~
            ~~- Конкретизируем цели, в приложении корректируем создаваемые и существующие флоу, по которым пользователь проходит через воронку. Цепляем метрики, снимаем показатели, и потом идём двумя путями:~~

            - ~~Смотрим метрику, видим просадки, смотрим почему сложности: сложно заполнять формы с десятками полей - ОКПО и прочие, авторизация, которая после логина скидывает весь заполненный процесс, и прочие ситуации~~
            - ~~Вместе с клиентом генерим новые гипотезы, оцениваем, внедряем и мониторим эффект от их внедрения. Из наилучших мною предложенных - сыграть на феномене потери упущенной выгоды, и снимать комиссию за операцию в конце сложного процесса, а не в начале. Почти на 35% увеличилась конверсия.~~
        - ~~Большой набор метрик, показателей, настроенных конверсий. Для пары проектов, гипотезы, буквально, были обозначены в рублях. Во сколько обошлась, и сколько принесла. Процесс затратный, но в том месте это имело смысл~~
        - ~~Благо, люди занимаются с пониманием, свои большие достижения, целый отдел, выхватывали и держали такие крупные проекты, как сервисы бронирования, ряд крупных промышленных заводов, продвижение в топ среди конкурентов, проект продвижения всех китайских автомобилей в РФ~~
- [x] **Тесты** - В полной мере:
    1. ~~**Виды тестирования**:~~
        1. ~~**Модульное -** проверка непосредственно самого модуля (функции, класса)~~
        1. ~~**Интеграционное -** интеграция, корректность работы с ближайшим окружением~~
        1. ~~**End-to-end -** проверка базовых флоу целиком, что бы понимать что целые процессы работают корректно (регистрация, покупка)~~
        1. ~~**Производительности -** что не падает под нагрузкой (куча товаров, блинный список комментов, частые запросы)~~
        1. ~~**Безопасности -** не подвержено уязвимостям~~
        1. ~~**UI - тестирование методом сравнения скриншотов.** Иногда может заменять собой End-to-end, или считаться его разновидностью~~
        1. ~~**Smoke** - очень быстрое, крупное. Цель - проверить что самое-самое главное в приложении работает корректно~~
    1. ~~**Пирамида тестирования:**~~
        1. ~~**Модульное** - (легко писать, быстро, дёшево)~~
        1. ~~**Интеграционное** - (потяжелей и подороже, но надо поменьше)~~
        1. ~~**End-to-end** - (долго, дорого, проверяют целый флоу, но их надо мало)~~
    1. ~~**Виды сценариев:** позитивные, граничные (для модульных), негативные. **Приоритет по порядку**~~
    1. ~~**Смысл тестов: пожалуй, одна из главных идей и смыслов наличия тестирования** - **это получить гарантии** того, что в том месте, где есть тесты - **гарантированно всё хорошо**. По этому, **просто наличие тестов - не показатель.** **Важно качество проводимого тестирования**, что бы они были написано в соответствии с теорией тестирования. Только в этом случае, их наличие может гарантировать, что решение качественно. И только в этот момент оно начинает себя оправдывать.~~
- [x] **Изучение** - Основные базовые штуки для фронта
    - [ ] Дочитать про рефакторинг
    - [x] Авторизация, и всё что с этим связано
    - [x] Корректная вёрстка
    - [x] Стейт-менеджмент
    - [x] Дебаг
    - [x] Прочитать книгу про проектирование домена на типах во фронте
    - [x] Архитектура фронтенда (чё кого куда и как). Отделение бизнес-логики от UI. Выделение самостоятельного домена.
        - [x] Контейнер/презентер
        - [x] Отдельный сервис, с выделенной логикой
        - [x] Логика в хуках
        - [x] Чистая архитектура / FSD и всё такое
- [x] **Просмотреть код проектов от яндекса**
    - [x] Просмотреть сами проекты
    - [x] Разобраться с ключами идемпотентности
    - [x] Создание доки как у них
    - [x] Авторизация
- [x] **Локализация и интернацализация -** i10n / i18n
    - [x] Локализацию (переводы текста)
    - [x] Интернационализация (изменение под нацинализацию - названия, описания, цветовые схемы, тексты, точки вместо запятых в числах, сокращения, направление письма, форматы дат и времени, форматы чисел и т.д.). При внедрении интернационализации важно обращать внимание на:
        - [ ] Используйте атрибут lang на теге .
        - [ ] Включайте локаль (например, en_US, zh_CN и т.д.).
        - [ ] Веб-страницы должны использовать **<link rel="alternate" hreflang="other_locale" href="url_for_other_locale">**, чтобы сообщить поисковым системам, что есть другая страница по указанному href с тем же содержимым, но на другом языке/локали.”
        - [ ] Локаль определяет **особенности используемого языка (английский для разных стран), формат и отображение дат, времени, чисел, направлений шрифта, и даже контента.**
        - [ ] Если язык отвечает непосредственно за сам язык, то локаль отвечает скорее за региональное расположение: страну, часть страны, или даже место без учёта государственных границ
        - [ ] Даже с учётом того, что локаль можно определить автоматически за счёт заголовка Accept-Language, редиректить напрямую пользователей не стоит, лучше всегда давать ему возможность самостоятельно выбрать какую версию сайта открыть.
        - [ ] Локализация может влиять на контент, его длину и объём (переполнение контентом). Его характер (цвета, акценты). Расположение слов и значений в текстах (переменные для цифр в переводе). Количественные обозначения и окончания (1 штука, штуки, штук)
        - [ ] **Весь контент** должен иметь возможность быть транснациализирован
- [x] **В целом, поднять системный уровень понимания вёрстки.** Что есть ещё помимо флексов. Гриды. Да и в целом, во флексах все эти flex-grow и прочее
- [x] **Авторизация** у нас на беке. Как работает, почему в куках есть данные о пользователях.
    - [x] JWT. Что зачем и как, как работает, базовые принципы. Почему считается защищённым вариантом
    - [x] Найти плюсы и минусы в сравнении с другими вариантами
    - [x] **Сессии / OAuth / OpenID / SAML / Basic-auth**
- [x] **Шрифты. Font-face**
    - [x] Дирректива подключения шрифтов. В целом, есть два подхода к подключению шрифтов:
        - [x] 1. Множество отдельных маленьких файлов со шрифтами. Каждый файл содержит только один вариант насыщенности шрифта (например, один файл содержит 400, другой 500, третий 700). Этот подход называется "Multiple Files Approach" или "Множественные файлы".
            - [x] **Удобная точечная настройка / быстрее загрузка страницы / можно что-то упустить / нужно ждать окончания загрузки всех фалов**
        - [x] 2. Один большой файл шрифтов, который содержит в себе все возможные свойства и их значения. Этот подход называется "Single File Approach" или "Единый файл". В этом случае все варианты насыщенности шрифта, начертания и другие свойства объединяются в один файл, который загружается один раз.
            - [x] Проще - всё в одном месте / но и летит всё вместе, даже не используемое - большой объём (130кб для одного из Roboto, против всего набора в 1.2Мб из 12 начертаний для него)
        - [x] В каждом из случаев будет подключен шрифт, и какой-то набор свойств (от одного до множества), и в последствии, браузер сможет выбирать подходящий файл в зависимости от указываемых свойств для шрифта в селекторе
- [x] Способы взаимодействия клиента с сервером
    - [x] **Реалтайм взаимодействие**
        - [x] **Web-Sockets - веб-сокеты.** WebSocket — это еще один протокол для отправки и получения сообщений. Как и HTTP, веб-сокеты отправляют сообщения через соединение TCP (протокол управления передачей данных).

            **Дуплексный режим подключения.** Позволяет серверу слать контент широкой рассылкой по группам, а не только одному клиенту (широкое оповещение клиентов).

            Формат сообщений свой, не запрос-ответ, а фрагменты данных (потому что могут слать туда-обратно вне какого-либо порядка)

        - [x] **Pooling - частые запросы** - просто частый опрос сервера, спаминг. Например, через каждые 500мс
        - [x] **Long pooling - долгие опросы.** Посылается запрос, сервер ждёт пока не появится инфа. Инфа есть - шлёт ответ, клиент получает ответ, и сразу же посылает следующий длинный запрос
        - [x] **Server-Sent Events** - однонаправленный способ связи. Позволяет серверу отправлять обновления клиенту, используя интерфейс **JavaScript EventSource.** Этот интерфейс создает постоянное однонаправленное соединение с сервером через HTTP и использует специальный заголовок текста/потока событий. В итоге все запросы обрабатываются кодом как события JavaScript, поэтому практически нет задержки между запросом и ответом. не позволяет использовать его для дуплексного общения. **Только слать с сервера на клиент**
        - [x] **Сервер-пуш** (отказались же?). Скорее, способ оптимизации, нежели формат соединения. Позволяет на стороне сервера определять потенциально востребованные в дальнейшем, клиентом, данные, и отправлять их ему заранее. Например: при загрузке станицы, понимая чт ов странице есть скрипты и стили - пушим в него с опережением (заранее, а не когда клиент запросит) эти дополнительные данные. Клиент, в итоге, будет заранее получать необходимые ему данные, ещё до того момента как решит что они ему нужны. Предзагрузка данных для клиента на основе предсказания.
        - [x] **WEB-RTC -** стандарт **Peer-to-Peer** связи между двумя клиентами, работающий поверх сети, в целом. Позволяет связать два клиента, и передать медиаконтент друг-другу без посредника
        - [x] Другие способы реалтайма - в принципе, это всё, что доступно в браузере. Есть и другие способы/протоколы, например: XMPP, AMQP, MQTT, но все они для других целей, и не приспособлены для работы в браузере.
    - [x] **HTTP - протокол**
        - [x] **Идемпотентность**:
            - [x] GET запросы
            - [x] PUT запросы
            - [x] DELETE запросы
            - [x] HEAD запросы
            - [x] OPTIONS запросы
            - [x] Но также, идемпотентными можно сделать и любые другие, добавив им кастомный заголовок с ключом, уникальным для каждой отдельной операции
        - [x] **Простые / сложные запросы. Сложными считаются запросы:**
            - [x] Запрос использует методы отличные от GET, POST, или HEAD
            - [x] Запрос включает заголовки отличные от Accept, Accept-Language или Content-Language
            - [x] Запрос имеет значение заголовка Content-Type отличное от application/x-www-form-urlencoded, multipart/form-data, или text/plain.
        - [x] **Preflight-запросы**
            - [x] Отправляются только перед **сложными запросами**
            - [x] **Preflight-запрос отправляется для проверки, разрешено ли выполнение основного запроса на сервере. Preflight-запрос содержит заголовки,** которые сообщают серверу о методе, используемом для основного запроса, **а также о заголовках, которые будут отправлены в основном запросе.** Если сервер разрешает выполнение основного запроса, он отправляет ответ с заголовками, которые сообщают браузеру, что основной запрос может быть выполнен. Если сервер не разрешает выполнение основного запроса, он отправляет ответ с соответствующими заголовками, которые сообщают браузеру, что основной запрос не может быть выполнен.
        - [x] **Все версии протоколов HTTP и его версий. Детали и различия, какие нововведения**
            - [x] Было 1.0 / 1.1 / **2.0** / 3.0
            - [x] Для использования требуется настроить сервак (и что бы браузер поддерживал выбранную версию)
            - [x] Преимущества версии **2.0**
            1. **Улучшенная производительность** - HTTP/2 использует новый механизм мультиплексирования, который позволяет одновременно отправлять несколько запросов и ответов через одно соединение. Уменьшает задержки и улучшает производительность при передаче большого количества небольших файлов.
            1. **Более эффективное использование сетевых ресурсов** - HTTP/2 **использует бинарный формат передачи данных** вместо текстового, что уменьшает объем передаваемых данных. **Кроме того, HTTP/2 поддерживает сжатие заголовков запросов и ответов**, что также уменьшает объем передаваемых данных.
            1. **Server-PUSH** уведомления **(depricated как сложная и проблемная)** - HTTP/2 позволяет серверу отправлять данные на клиент до того, как они будут запрошены клиентом. Это уменьшает задержку и улучшает производительность при передаче связанных между собой файлов, таких как HTML, CSS и JavaScript.
            1. **Безопасность** - HTTP/2 поддерживает только защищенное соединение TLS/SSL, что повышает безопасность передачи данных.
            1. **Более гибкий и расширяемый** - HTTP/2 использует бинарный протокол, что делает его более гибким и расширяемым, чем HTTP/1.1, позволяя добавлять новые функции и улучшения без изменения протокола.
            1. **Поддержка приоритетов** - HTTP/2 поддерживает установку приоритетов для каждого запроса, что позволяет определить, какие запросы важнее, и обеспечивает более эффективное распределение ресурсов и ускорение загрузки страницы.
            1. **Поддержка кэширования** - HTTP/2 поддерживает новые возможности кэширования, которые улучшают производительность и снижают нагрузку на сервер.
            1. **Безопасность от DoS-атак** - HTTP/2 поддерживает защиту от DoS-атак, используя механизмы управления потоками и управления подключением.
        - [x] Детали работы протоколов TCP/IP. Что такое, в чём особенности. Точная разница между ними
            - [x] **Тройное рукопожатие - обмен стандартными пакетами для создания и запуска подключения**
            - [x] **Как работает TCP соединение** - Если в запросе присутствует заголовок **Keep-Alive**, то сервер может удерживать этот **сокет открытым** и **ожидать следующего запроса от клиента**. После того, как сервер отправляет ответ на запрос, **он также оставляет сокет открытым**, чтобы можно было повторно использовать его для следующего запроса, если он поступит. Это позволяет сократить время для следующего подключения. **Время экономится именно на создании TCP соединения (поверх которого уже будет работать HTTP)**
    - [x] **HTTP** - основной протокол передачи данных в Интернете, который использует запросы и ответы для обмена информацией между клиентом и сервером.
    - [x] **HTTPS** - это защищенная версия протокола HTTP, которая использует шифрование для защиты передаваемых данных от несанкционированного доступа.
    - [x] **SPDY (pronounced "speedy")** - протокол для передачи веб-контента, который улучшает производительность приложений в Интернете.
    - [x] **QUIC (Quick UDP Internet Connections)** - протокол, разработанный Google, который сочетает в себе преимущества UDP и TCP, обеспечивая быстрое и безопасное соединение в Интернете.
    - [x] **FTP (File Transfer Protocol)** - протокол, используемый для передачи файлов между сервером и клиентом.
    - [x] **SMTP (Simple Mail Transfer Protocol)** - протокол, используемый для отправки электронных писем между почтовыми серверами.
    - [x] **XMPP (Extensible Messaging and Presence Protocol)** - протокол, который используется для обмена мгновенными сообщениями и присутствием в режиме реального времени между различными устройствами и системами.
    - [x] **RUDP (Reliable User Datagram Protocol)** - протокол, который объединяет в себе преимущества UDP и TCP, предоставляя быстрое и надежное соединение для передачи данных.
    - [x] **CoAP (Constrained Application Protocol)** - протокол прикладного уровня для обмена данными в сетях с ограниченными ресурсами, такими как Интернет вещей (IoT).
    - [x] **MQTT (Message Queuing Telemetry Transport)** - протокол связи для Интернета вещей (IoT), который используется для передачи сообщений между устройствами.
    - [x] **AMQP (Advanced Message Queuing Protocol)** - протокол, который используется для обмена сообщениями между компьютерными системами.
    - [x] **SCTP (Stream Control Transmission Protocol)** - протокол транспортного уровня, который обеспечивает передачу нескольких потоков данных между двумя хостами.
- [x] Работа с сетью
    - [x] **Ретраи**. По количеству, по времени, по ключам идемпотентности (есть понимание что, как и зачем. Можно нагенерить через нейронку)
    - [x] **Дебаг SSR запросов** - в целом, дебажить либо через консоль либо через прокси (что бы увидеть содержимое запроса как в инструментах разработчика)
- [x] Все инструменты фронтенд-разработки. Разобрать и классифицировать.
- [x] Потренироваться в работе с нейронками. Посмотреть и поискать плагины для ИДЕ
- [x] Пакетные менеджеры
    - [x] npm и npx. В целом, npm и npx - это два разных инструмента, которые выполняют разные задачи. npm используется для управления пакетами в проекте, а npx используется для запуска команд из пакетов без установки их на компьютер.
        - [x] **npm** - используется для управления пакетами в проекте, например, для установки, удаления или обновления зависимостей. Он также может использоваться для запуска команд, которые содержатся в пакете, но для этого пакет должен быть установлен локально или глобально.
        - [x] **npx** - используется для запуска команд из пакетов, которые не установлены локально. Это позволяет запускать любую команду из любого пакета без установки его на компьютер.
    - [x] Альтернативы для npm: nvm, yarn и т.д.
        - [x] **yarn** - как npm, но со своими тонкими приколами. Где-то лучше, где-то хуже (обновление дев-зависимостей и прочее). Но в целом, качает обновления быстрее
        - [x] **nvm (как и n)** - управление версиями NodeJs на устройстве
    - [x] **Babel** (работа с js - транспиляция, из ts в js, обработка кода - минимизация, удаление неиспользуемого кода, транспиляция JSX, поддержка полифиллов: Babel может автоматически добавлять полифиллы для функций, которые не поддерживаются в браузерах, в которых запускается ваш код.)
    - [x] ~~**Вебпак**~~**. (Инструмент для создания бандла приложения из набора файлов (код, разметка, стили, графика и другое). Так же позволяет создать очень сложный процесс конфигурации проекта, включая подгрузку файлов и разделение бандлов - по одному маленькому бандлу для каждой страницы, почти как критикал CSS)**
- [x] **Пре и пост процессоры. Автопрефиксы. Кроссбраузерная вёрстка.**
    - [x] Пре- и пост- процессоры используются для обработки и манипулирования стилями. Минимизация, префиксы
    - [x] На текущий момент, **автопрефикс** уже встроен в утилиты **create-react-app** и другие. И это решает проблему кроссбраузерной вёрстки через префиксы. Но не решает более серьёзные проблемы, например, отсутствие календаря в сафари. В таких случаях, приходится создавать полностью новый календарь для этого браузера
- [x] Законспектировать задачи из собеса с ВК
- [x] Когда я импортирую модуль
    - [x] **При каждом импорте я вызываю НЕ новый инстанс, а импортирую одну и ту же сущность (и присваивая в него что-то в одном месте, я могу это увидеть в другом)**
- [x] Смысл Аксиоса, когда уже всё это есть в фече (или не всё?).
    - [x] **Автоматическое оборачивание проблемных ответов в ошибки. Если запрос завершается неудачно (вне диапазона 200-299), axios генерирует исключение, которое мы перехватываем в блоке catch**
    - [x] **Axios interceptors.**
    - [x] **Преднастройка инстансов (заголовки с параметрами)**
    - [x] **Возможность отмены запросов**
    - [x] **Поддержка междоменных запросов (withCredentials: true)**
    - [x] **Кросс-браузерная поддержка**
- [x] Объект Date. Работа с датами
    - [x] **Во всех импортах/экспортах формат входящей даты должен совпадать с форматом выходящей.**
    - [x] **У JS очень плохой Date. У него плохая интуиция. Например, нумерция месяцев с 0, мутное API, непрозрачная работа с часовыми поясами. Поэтому всегда стоит юзать dayjs**
    - [x] **Лучше не юзать implicit конструктор. Парсь даты через подсказку, у них щас это второй аргумент конструктора dayjs("12.12.1995", "DD.MM.YYYY") Не хочешь сюрпризов для дат вида 07.07.1995 где семь может быть и месяцем и днём — не давай либе решать**
- [x] **css-in-js (Styled-components)** [(стили описываются в js. Из компонентного подхода. Говорят удобно, но это сомнительно. Своеобразный подход, который, наверное, имеет шанс на жизнь)]
- [x] **Сommand query separation CQS** - **[(Согласно этому принципу, каждая функция является либо командой, которая выполняет действие (action), либо запросом (query), который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.)]**
- [x] **Методы оптимизации сайтов**
    - [x] 0 Корректный бандлинг (только то, что нужно)
    - [x] 1 Минификация JS-файлов
    - [x] 2 то же и с css
    - [x] 3 собрать изображения в спрайты
    - [x] 4 кеширование
    - [x] а) файлы js и css кешируются навсегда( или на длительный период, к примеру на год), когда в них вносятся какие-то изменения, в результате разработки, меняется номер версии, браузер считает, что это новые файлы и закачивает их. Время кеширование содержится в заголовке expires.
    - [x] б) файл кешируется до тех пор, пока в нем не произошли изменения. Когда пользователь в первый раз заходит на сайт, у него еще нет кеша, файлы закачиваются и в следующий раз, когда происходит обмен заголовками происходит анализ ETag(хеш суммы содержимого содержимого файла или хеш последнего времени изменения, или номер версии) Если он изменился, то закачивается, в противном случае, берется из хеша.
    - [x] Так же можно брать заголовки с датой последней модификации(Last_Modifed), но это менее надежно.
    - [x] в) можно сжать данные перед отправкой, решается настройкой конфига в nginx. Пример. Content-Encoding: gzip
    - [x] г) можно разбить js на модули и на разных страницах подключать по мере необходимости.
    - [x] Можно найти еще несколько, но они менее популярны или устарели.
    - [x] Серверный рендеринг, с различными моделями
    - [x] Динамический импорт и подгрузка
    - [x] Работы с изображениями
1. **Разработка SPA, базовые шаблоны/паттерны проектирования**
    1. **Паттерн фасад - сокрытие различных АПИ за одним интерфейсом**
        1. Применялся на яндекс пее для сокрытия различных АПИ за одним интерфейсом, а внутри перекрёстные запросы, очереди запросов и т.д.
    1. **B4F - подход, при котором у фронта есть свобственный мини-бек.**
        1. Как мидлвара
        1. Как Gateway, как фасад, предоставляя унифицированное АПИ для работы с набором разнообразных внешних сервисов (АПИ)
        1. Кеширование, оптимизации, дополнительные работы
        1. Предоставляет дополнительный уровень абстракции: изолирует сложность, позволяет разграничить и снизить зацепление фронта и бека по АПИ-контрактам
        1. Предобработка контента (мапинг данных из нескольких источников, нормализация), и всё это выгоднее делать на серверной машине
        1. В принципе, удобнее замокать при тестировании
        1. Есть в Нексте из коробки, можно самим написать
        1. **На Я.Пей применяли Б4Ф при серверном рендеринге, а фасад при клиентских запросах**
        1. **Из минусов:**
            1. Накладные расходы: развёртывание, поддержка, тот же дополнительный уровень абстракции с дополнительной логикой и необходимостью обрабатывать все кейсы, а это N+X сценариев выполнения
    1. **Принципы клиентской оптимизации React приложений**
        1. Во-первых, нужно понять есть в чём именно проблема, убедиться что она точно есть, после уже найти место и причину, и только потом фиксить то, что мы хотим оптимизировать. **Важно понимать в каком именно месте у нас проблемы**
        1. Конкретные методы оптимизации:
            1. **Critical rendering path** ==(Критический путь рендеринга) - период от момента запроса HTML-документа к серверу, его получения, и до момента его преобразования в пиксели на экране==

                ![[Untitled 2.png|Untitled 2.png]]

                1. **Приоритет и контроль порядка загрузки ресурсов** - разместить скрипты в нужном порядке, с нужными приоритетами загрузки
                1. **rel="preload" - указать предзагрузку для ресурсов. Для ресурсов (скрипты, стили, шрифты, изображения и т.д.)** - при загрузке контента, приоритет для помеченных **preload**
                1. **Уменьшить размеры ресурсов** - размеры изображений (подгружать только нужные, под юзер-агент, srcSet, imageProxy, ImageComponent)
                1. **Оптимизации размера бандла (код, зависимости, шрифты, стили)**
                    1. Определить, что бандл в проекте излишне велик - **Webpack Bundle Analyzer**
                    1. Использовать адекватные пакеты, вместо устаревших полновесных **(dayjs вместо moment, slick вместо swiper)**
                    1. Корректный импорт из библиотек **(по отдельности, а не весь пакет как в лодаш)**
                    1. Не тащить полновесные шрифты по нескольку мегабайт, а подключать только необходимые
                1. **Использование асинхронной загрузки для скриптов -** использовать `**async**` или `**defer**`.
                    `**async**` позволяет загрузке скрипта начаться сразу, не блокируя HTML-разбор. Выполнится после загрузки скрипта
                    `**defer**` откладывает выполнение скрипта до завершения разбора HTML.

                1. **Работа непосредственно с CSS может заблочить рендеринг и выполнение скриптов (пока строится CSSOM)**
                    1. Минификация, удаление лишних стилей
                    1. Разделение бандла со стилями на отдельные пакеты (минимально необходимые для страницы)
                    1. Загрузка по предусловиям - только для мобильных экранов: <link rel="stylesheet"href="mobile.css"media="screen and (max-width: 480px)" />
                    1. Корректней работать с анимациями (не вызывающими рекомпозицию)
                1. **Динамическая подгрузка модулей React.lazy и Suspense и изображений**
            1. **Оптимизация вычислений**
                1. Мемоизация компонентов, расчётов, useCallback, селеторы данных из стора (reselect, но в toolkit уже вклёчен)
                1. Виртуализация (таблицы, списки, коллекции), скользящие окна
                1. Для ресурсоёмких задач (по времени вычисления и памяти) - подбор нужных алгоритмов и СД
            1. **Оптимизация внутренних скриптов, лишних рендеров и т.д.**
                1. Снижение связанности бизнес-логики и view. Независимые модули и компоненты
                1. Корректная декомпозиция на компоненты, для уменьшения количества рендеров
            1. **Тесты производительности, метрики лайтхауса, code coverage (процент используемых скриптов)**
            1. **Оптимизация с предзагрузкой новых страниц, модулей, контента**
                1. **КешАПИ - при переходах вперёд-назад не загружать страницы заново, а использовать Navigation API, и кеш страниц**
                1. **Кеширование, в целом**
                1. На примере проектов посмотреть и понять какие варианты есть и как они работают в Next.js (серверная генерация). Как это работает, как потом загружаются новые страницы - при клике по ссылке загружается полностью новая страница или только json для неё?
    1. **Практики UX/UI**
        1. Исследование ЦА
        1. Создание Карт пользовательского пути - основные кейсы
        1. Прототипирование для наглядности
        1. Тестирование на пользователях - канареечные релизы
        1. А/Б - тестирование. Проверка на практике различных подходов (что лучше для пользователя, где больше вовлечения)
    1. **HTML5, CSS3, кроссбраузерная (Safari/IE11+,e.t.c)/адаптивная вёрстка**
        1. Кроссбраузерная
            1. Привести всё к одному виду. **Reset.css или normalize.css.**
            1. Вендорные префиксы (o- Опера, -moz- Mozilla, -ms- Internet Explorer 8 -webkit- Safari Chrome Edge)
            1. Кнопки в сафари не могли быть флекс-контейнерами. Элементами - да, контейнерами - нет. Просто такая философия. Но потом пофиксили
            1. Стилизация **placeholder** для **input**-ов: где-то это как псевдоэлемент, а какие-то — как псевдокласс.

                ::-webkit-input-placeholder { /* Chrome/Opera/Safari */

                ::-moz-placeholder { /* Firefox 19+ */

                :-ms-input-placeholder { /* IE 10+ */

                :-moz-placeholder { /* Firefox 18- */

            1. **Подобные задачи решают автопрефиксы и пост-css плагины и т.д.**
                1. **Им в помощь Browserslist**, в котором определяется под какие версии каких браузеров требуется адаптировать стили и применять дополнительные шаги
                1. [caniuse.com](http://caniuse.com/) - для проверки поддерживаемости

### RTK-Query

**Занимается управлением запросами и их кешированием (настраиваемым)**

Хуки

1. useQuery - зарос данных, с кешированием
    1. Кеширует результаты запроса, сохраняя кеш под ключом на базе args запроса - конкатенирует их в строку
    1. Может вызываться в разных частях приложения, и если запрос одинаковый - возвращает кеш, если запрос новый - запрашивает его, и сохраняет результаты в кеше под другим ключом
1. useMutation - отправка действий, для изменения состояния на беке
    1. Возвращает метод, для вызова АПИ, и объект состояния
    1. Срабатывает не автоматически, а только при ручном тригеринге

Фичи

1. **Кеширование**
    - Работает на тегах
    - Когда тег (относительно простой фрагмент данных) становится не валидным, все АПИ помеченные таким ключом, повторно отправляют запросы
    - Работа с тегами состоит минимум из 3 частей:
        - A root `tagTypes` или `tagTypes` (если используется сплиттинг АПИ) - описывает все ключи, встречаемые в АПИ (слайсе АПИ)
        - A `providesTags` массив тегов в каждой ручке, который описывает содержимое этих АПИ
        - An `invalidatesTags` массив тегов, указываемых в mutation-АПИ, становящиеся недействительными каждый раз, когда вызывается это mutation-АПИ
    - Каждый раз, когда срабатывает mutation-запрос, все ключи описанные в нём становятся не действителными. И другие запросы срабатывают повторно
    - Оптимизации инвалидации
        - Не всегда простая базовая настройка кеша сработает оптимально. Иногда ключи перекрывают слишком большое количество точек и данных, тригеря все ручки, в которых указан выбранный простой ключ
            В подобных случаях можно использовать более точечные теги, например как: `{type: 'Post', id: 123}`

        - Это работает и для `providesTags`  и для `invalidatesTags`

            ```JavaScript
            providesTags: (result = [], error, arg) => ['Post', ...result.map(({ id }) => ({ type: 'Post', id }))]
            ```

        - Благодаря этому, теперь можно будет более точечно настроить тегами каждый ендпоинт на тригеринг и инвалидацию кеша
            - `getPosts`: provides a general `'Post'` tag for the whole list, as well as a specific `{type: 'Post', id}` tag for each received post object
            - `getPost`: provides a specific `{type: 'Post', id}` object for the individual post object
            - `addNewPost`: invalidates the general `'Post'` tag, to refetch the whole list
            - `editPost`: invalidates the specific `{type: 'Post', id}` tag. This will force a refetch of both the _individual_ post from `getPost`, as well as the _entire_ list of posts from `getPosts`, because they both provide a tag that matches that `{type, id}` value.
        - Не стоит забывать, и детальнее понимать, что на списки сущностей это тоже влияет точечно. Если у них описаны одиночные теги, то их тоже стригерит, если мутация инвалидирует такой же тег
        - Обратить внимание на правила формирования составных тегов: в query - это результаты запроса, а в mutation - это аргументы запроса.
        - Если первых двух вариантов не хватает, то можно кастовать дополнительные специфичные, какие только угодно. Даже мета-теги, несущие просто дополнительную семантику `{type: 'Post', id: 'LIST'}`
        - ТАК РАБОТАЕТ КЕШ
1. **OptimisticUI**
    1. Подход, при котором изменения в UI отображаются сразу же, до получения ответа от сервера о реально возникших изменениях
    1. Как работает? На жизненных циклах запросов
        1. onQueryStarted - при запуске запроса
            1. Создаётся ручное изменение кеша объекта, и в случае не успеха запроса, запрос просто откатывается назад
1. **Открытые вопросы**
    1. Оптимизация извлечения данных - вытаскивать только порционно - [https://redux.js.org/tutorials/essentials/part-8-rtk-query-advanced#selecting-values-from-results](https://redux.js.org/tutorials/essentials/part-8-rtk-query-advanced#selecting-values-from-results)
    1. Оптимизация вычислений - (там же, но ниже) - [https://redux.js.org/tutorials/essentials/part-8-rtk-query-advanced#selecting-values-from-results](https://redux.js.org/tutorials/essentials/part-8-rtk-query-advanced#selecting-values-from-results)

### Принципы и паттерны во фронтенде

- [x] Принципы и паттерны во фронтенде

    **SOLID**

    1. ~~**Принцип единой ответственности (Single Responsibility Principle, SRP):**~~
        ~~Каждый компонент должен иметь только одну причину для изменения: **Пример: Разделение компонентов для отображения данных и обработки логики взаимодействия с данными.**~~

    1. ~~**Принцип Открытости/Закрытости (Open/Closed Principle, OCP):**~~
        ~~Программные сущности должны быть открыты для расширения, но закрыты для изменения.~~

        ~~Пример: В фронтенде это может быть достигнуто через использование интерфейсов и абстракций. **Создание абстрактных компонентов, которые могут быть расширены новыми конкретными реализациями.**~~

        ```JavaScript
        javascriptCopy code
        // Плохо - компонент жестко зависит от конкретной реализации валидации
        class OrderValidationComponent {
            validate(order) {
                // ...
            }
        }

        // Хорошо - компонент использует интерфейс для валидации, который может быть расширен
        class OrderValidationComponent {
            validate(order, validator) {
                // ...
            }
        }
        ```

    1. ~~**Принцип Подстановки Базового класса на место производного (Liskov Substitution Principle, LSP):**~~
        ~~Объекты базового класса должны быть заменяемы на объекты производного класса без изменения правильности программы.~~

        ~~Пример: Обеспечение корректной работы субклассов вместо их родительских классов.~~

        ```JavaScript
        javascriptCopy code
        // Плохо - подкласс нарушает ожидаемое поведение родительского класса
        class Square extends Rectangle {
            setWidth(width) {
                this.width = width;
                this.height = width;
            }

            setHeight(height) {
                this.width = height;
                this.height = height;
            }
        }

        // Хорошо - подкласс соответствует ожидаемому поведению родительского класса
        class Shape {
            // ...
        }

        class Square extends Shape {
            setSideLength(length) {
                this.width = length;
                this.height = length;
            }
        }
        ```

    1. ~~**Принцип Разделения интерфейса (Interface Segregation Principle, ISP):**~~
        ~~Клиенты не должны зависеть от интерфейсов, которые они не используют. Во фронтенде это может быть связано с разделением крупных компонентов на более мелкие и специализированные.~~

        ~~Пример: Разделение монолитных компонентов на более мелкие, чтобы клиенты не зависели от неиспользуемых методов.~~

        ```JavaScript
        javascriptCopy code
        // Плохо - клиенты вынуждены реализовывать методы, которые им не нужны
        class BigComponent {
            methodA() {
                // ...
            }

            methodB() {
                // ...
            }
        }

        // Хорошо - разделение компонента на более специализированные интерфейсы
        class SmallComponentA {
            methodA() {
                // ...
            }
        }

        class SmallComponentB {
            methodB() {
                // ...
            }
        }
        ```

    1. ~~**Принцип Инверсии зависимостей (Dependency Inversion Principle, DIP):**~~
        ~~Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.~~

        ~~Пример: Использование внедрения зависимостей и инверсии контроля для обеспечения слабой связности между компонентами.~~

        ```JavaScript
        javascriptCopy code
        // Плохо - зависимость от конкретной реализации сервиса
        class OrderService {
            constructor() {
                this.apiService = new ApiService();
            }
        }

        // Хорошо - использование инверсии контроля через внедрение зависимости
        class OrderService {
            constructor(apiService) {
                this.apiService = apiService;
            }
        }
        ```

## Vite

**Vite** - инструмент для сборки проектов. Быстр, прост, удобен, готов к работе “из коробки”. Полнофункционален, поддерживает плагины, и вообще, пушка

**Интро**

Использует под капотом сборщики. Разные на отдельных этапах, пытаясь извлечь лучшее из обоих

**Esbuild** и **Rollup** - чисто сборщики. **Vite** пользуется обоими на разных этапах работы

**Esbuild** - там, где не нужна работа с **ES modules**:

- Пребандлинг внешних зависимостей к оптимальной работе - приводит всё к ESM, правит импорты и все требуемые составные модули (состоящие из нескольких внутри) преобразует в один целостный отдельный
- Не юзается в других местах из-за несовместимого АПИ и проблемой с es-модулями

**Rollup** - для сборки итогового продакшн бандла, для работы с ES-модулями

**Rollup**, а не **Esbuild**, потому что со вторым тяжело работать из-за сложностей АПИ. Но скоро перекрутят Rollup в RollDown и всё будет так же быстро и красиво

**Плюсы:**

- СИЛЬНО ПРОЩЕ В НАСТРОЙКЕ И УПРАВЛЕНИИ, И ЗНАЧИТЕЛЬНО БЫСТРЕЕ (В РАЗЫ)
- Hot-replcae при разработке. Позволяет применять изменения в коде без перезагрузки страницы и без необходимости пересобирать весь проект. Это особенно важно для быстрых итераций разработки.
- Быстрый Старт и Горячая Замена Модулей (HMR): Использование нативных ES модулей для разработки обеспечивает мгновенный старт и быстрый HMR.
- - За счёт ES-модулей (напрямую в браузер, за счёт чего он управляет, подгружает, предварительно компилирует при rel='vodulePreload', кеширует и другие плюсы браузера).
- - При том, что вебпак больше ориентирован на работу с бандлами, и вынужден пересобирать бандлы постоянно.
- Автоматическое чанкование
- Все рядовые шутки тоже уже поддерживает через плагины, включая тот же Module-federation для микрофронтендов и другое
- vitest - просто удобнее работать над тестами
- Динамический импорт с авторазедлением на те же чанки (хотя не скажу точно, но в вебпаке, наверняка, такое тоже есть. Ну хотя бы просто по тому, что фича важная - должна быть)
- Простота настройки: Меньше конфигурации "из коробки" для стандартных проектов.
- Обрабатывает CSS через PostCSS, но при необходиомсти можно поправить конфигурации под LightingCSS
- Оптимизирован для Современных Браузеров: Сфокусирован на использовании современных стандартов, что может улучшить производительность.
- Использование Rollup для Продакшен-сборки: Наслаждается преимуществами Rollup, включая эффективное разделение кода и tree-shaking.
- Встроенная поддержка TypeScript и Vue: Упрощает работу с этими технологиями.

**Минусы**

- Ограниченная Поддержка Старых Браузеров: Vite оптимизирован для современных браузеров и может требовать дополнительных настроек для поддержки старых браузеров.
- Меньше Плагинов и Интеграций. Но основные есть
- Кажется, отсутствует встроенный удобный механизм префетчинга модулей. Что бы получать фоном.
- - Возможно, для этого есть плагин
- - Хороший пример для изящной деградации. Чекать скорость подключения клиента, и если она ок (например, по косвенным показателям - скорости загрузки известного чанка) - объявлять о скорости подключения. И исходя из этого либо разрешать фоновую подгрузку контента, либо загружать только по требованию. Что бы это не блочило интерфейс при медленном подключении (ну и зависит от поведения пользователя - активно он работает со страницей, или нет)

**Открытые вопросы**

- Допинать тему с тем, как добиться префетчинга/прелоадинга динамически импортируемых модулей в приложении. Динамический import разделит на отдельные чанки, но как именно подгрузить именно их?
- Нам нужен такой прелоадинг чанков в приложении? Например такой:

    [https://github.com/CaptainLiao/vite-plugin-webpackchunkname](https://github.com/CaptainLiao/vite-plugin-webpackchunkname)

    - позволит корректно поправить и добавить подгрузку соответствующих страниц тогда, когда нам это потребуется. Например, страницу с созданием ответа, при просмотре страницы с письмом

---

## Микрофронты

Подход, при котором большое приложение может состоять из других, как правило, более мелких

**Имеет много плюсов:**

- Масштабирование по командам, по проектам, по технологиям, по бизнес-направлениям, группировки (на главную вставить виджеты из разных департаментов) и т.д.
- Шарить зависимости между проектами
- Шаринг приложения на несколько мест (кредитный калькулятор, виджеты, окна заказов, рекомендательные группы товаров и прочее)

**Но и минусы:**

- Нужно управлять всем этим зоопарком
- Всякие дополнительные штуки (моки, инструментарий, потенциально другие вещи) могут вызывать проблемы, при необходимости работы с ними. Подумать над тем, как это можно разрешить - проверять наличие msw, в промежуточном слое через ping, и если его там нет - инджектить свой, а если есть - дополнительно подключать свой набор моков в него (через inject или что-то такое). НННООООО тогда будет проблема, если у тебя несколько дочерних апп стоят, и каждый будет сетить своё, если нет головного. В головном нужно реализовать метод через контекст. Справшиваем - есть ли мок, и если есть - инджектим туда наше. А если нет - просим поднять, и прокидываем в него набор наших моков. Посмотреть что там будет при перезатирании наборов моков
- А если там не будет пропускать запросы на те роуты, для которых не описаны моки - прокидывать их без блокировки

**ПРОБЛЕМА**: шаринг зависимостей, когда они большие, но нужны лишь частично. Трее-шейкинг, даже если он есть, не решит проблему в этом месте - он не понимает что именно извлекать, и по тому, тащит либу целиком.

- Как фиксить - импортить модули по отдельности. Прямо делить на отдельные части, и вытаскивать из либы по отдельности. И тогда будут переиспользоваться атомарные зависимости. ПРОВЕРИТЬ, ЧТО ЗАВИСИМОСТИ загруженные из микрофронта А будут доступны в мкрофронте Б - как это првоерить? Через инструменты разработчика? Через бандланалайзер?

(ВКЛЮЧИТЬ В ПОДГОТОВКУ К СОБЕСАМ. ПРОТЕСТИРОВАТЬ ЭТО НА ОТДЕЛЬНОЙ ЛИБЕ С ВОЗМОЖНОСТЬЮ РАЗДЕЛЕНИЯ НА ОТДЕЛЬНЫЕ МОДУЛИ С ТРЕЕШЕЙКИНГОМ - должно сработать. Можно на примере того проекта из книги)

- А как быть с общими зависимостями? Если там одни и те же зависимости в разных микрофронтах, то как их подтягивать лишь один раз на каждый микрофронт, ведь ссылки на них и имена этих чанков разные и не могут быть одинаковыми

**Проблемы с микрофронтами**

- Модуль-федератион на vite работает криво. Проблемы с тем, что бандлы как-то криво собираются, даже в одном чанке - периодически отваливается доступ к рефам (в частности), в рандомные моменты. Проблема есть, когда пофиксят - не понятно
- На вебпаке начинать - нуу..... дай бог светлой памяти такой инициативе. Зачем?
- Монорепы - тоже такое себе
- Сабмодули - ну... м.б. вебпак всё же? Вообще же треш
- Тежелее следить за состоянием проекта в каждой его части. Много частей - много участников, свои интересы, по чужим проектам не отследить состояние. Монолитный фронт - тяжело и много проблем, но всё равно их меньше, чем обычно

---

## Браузер (1)

## Безопасность в WEB (✅)

### Про безопасность в WEB в целом:

**Что нужно понимать в целом: веб - это шаткое место, и защита сайта это не про “закрыть один лючок с уязвимостью”. Это комплексное решение**

**Как обезопаситься:**

1. В первую очередь, следует защитится от **XSS**-атак**.** Для этого тщательно чистить и санитайзить все данные
1. Защититься от **CSRF**-уязвимостей. Использовать токены для подтверждения легитимности своих действий
1. Но даже имея защиту от **XSS**, всё равно следует помнить что один прогиб и ты погиб - в любой момент может открыться новая точка для **XSS**-атаки, а потому для всех последующих уровней в приложении так же необходимо поддерживать защиту и безопасность (токены хранить в недоступных для детей местах)
1. Настроить **CSP**
1. Обезопаситься от остальных атак, по типу **Clickjacking** и прочих

**Краткая история (с причинами) развития механизмов:**

1. Изначально не было никаких ограничений
1. Почти сразу после этого появилась политика **Same Origin Policy (SOP)**, запрещающая кроссдоменное использование ресурсов и запросов - тем самым защищает клиента от потери данных.. **Для общей безопасности. И это было хорошо**
1. Жить с **SOP** было сложно: она позволяла вставлять различный контент (скрипты, медиа, стили), но не позволяла выполнять запросы (и многое другое) на разные домены, поддомены со статикой, метрики и аналитики, АПИ. Всё это требовало кроссдоменых запросов
1. Решили придумать механизм, позволяющий переопределить **SOP**, и контролируемым образом разрешать кросдоменные запросы.
1. Таким решением стали **Cross Origin Resource Sharing (CORS).** Они позволяли ослабить **SOP** там, где это необходимо (**AJAX запросы, etc**). Правила поведения и разрешений описываются на сервере, через дополнительные заголовки.
1. Стало лучше, но одновременно с этим появилась огромная проблема: стали возможны расширенные **XSS-атаки**
    1. Если раньше воровство и пересылка данных на другой ориджин не могла бы быть осуществлена из-за прямых запретов **SOP**, то сейчас само появление корсов сделало их возможным: сторонний сервер просто ставил открытые корсы, и браузер без проблем позволял отсылать на него чувствительные данные
    1. И это было очень большой проблемой. Вместе с хорошим приехали большие угрозы
1. Понимая это, вместе с корсами практически сразу же была разработана и внедрена новый механизм **CSP**. Механизм позволял жёстко настраивать всё, что касается работы с контентом
    1. Ограничивать источники для загрузки контента
    1. Ограничивать домены, на которые можно посылать запросы
    1. И много другого полезного стафа

    Таким образом, эта политика позволяла закрыть все дыры появившиеся после появления корсов

    По умолчанию, ограниченно позволяет некоторые не критичные кроссдоменные запросы

### Виды уязвимостей:

- **XSS**
- **CSRF**
- **Clickjacking**
- **SQL**
- **noSQL**
- **LDAP**
- **XPath**
- **Не столько уязвимости, но вещи, о которых нужно помнить**
    - **POR** - **Предсказуемые идентификаторы объектов (Predictable Object References)**
    - **DDoS** - дддудудос-дудудуудудос!
    - **Использование устаревших компонентов и библиотек** (Outdated Components)
    - **Открытые точки доступа к API** (не закрытые за авторизацией)
    - **Отсутствие или недостаточность валидации ввода пользователем**

### Описание уязвимостей:

- **CSRF** - (Cross-Site Request Forgery, CSRF) - Межсайтовая подделка запроса - это тип атаки на веб-приложения, при которой **злоумышленник заставляет жертву выполнить нежелательные действия на стороннем веб-сайте, на которому она уже аутентифицирована.** Атака происходит за счет того, что браузер жертвы автоматически отправляет запросы на другой сайт без явного согласия или даже без ее знания. Происходит это от имени жертвы, но без её согласия

    **В целом, это попытка от лица пользователя, находящегося на сайте Б совершить действие на сайте А (и он на нём авторизован) и получить профит с этого злоумышленнику**

    - **Возможный сценарий:**
        1. Жертва авторизуется на сайте **"A"** и получает аутентификационные куки.
        1. Жертва переходит на вредоносный сайт **"B"**, который содержит скрытые или автоматически выполняющиеся запросы на сайт **"A"**.
        1. Незаметно для жертвы, браузер отправляет запросы на сайт **"A"** с аутентификационными куками, чтобы выполнить нежелательные действия на сайте **"A"**, такие как изменение профиля, отправка сообщения и т.д.
        1. При этом подобные запросы могут беспроблемно выполняться, поскольку куки авторизации отправляются автоматически, при совершении запроса на сайт **“А”**
    - **Методы борьбы с этим:**
        - `**CSRF**` **токены** - специально генерируемые уникальные записи, создаваемые для каждой сессии или для каждого запроса, действующие как отдельное дополнительное средство идентификации, недоступное злоумышленнику для использования
            - **Главное - передавать его с каждым запросом на сервер,** и далее аутентифицировать запрос пользователя с этим токеном, но при этом не давать злоумышленнику возможность получить доступ к этому токену
            - Передавать можно несколькими способами (но следует выбирать только те, к которым не может быть доступа через **XSS**:
                - **Безопасные:**
                    - **Хранить в теле формы,** тогда браузер автоматически подтянет это значение из формы, и отправит в запросе. ==**НО ТОЛЬКО ЕСЛИ есть защита от XSS-атак.**
                        ==**Но в целом, это уже не самый рекомендуемый способ.** В основном, сейчас другие подходы к работе с такими токенами и обработкой запросов пользователей

                    - **В куки - безопасен ТОЛЬКО ЕСЛИ httpOnly**, иначе опасно, потому что куки могут быть доступны для сторонних скриптов в случае **XSS-атаки.**
                        **Отправляется автоматически на нужный сайт благодаря Same-Origin Policy (SOP)**

                    - Заголовок запроса (**X-CSRF-Token**) - Имя может быть любым. **Безопасен, так как не доступен для сторонних скриптов из-за Same-Origin Policy.**
                    - **В теле запроса (POST или PUT запросы)** - Безопасен, так как токен не хранится на странице и не доступен для сторонних скриптов через DOM.
                    - В **localStorage** или **sessionStorage** - Безопасен, **если ваше приложение не подвержено XSS** и умеет правильно обрабатывать токен из хранилища.
                - **Не безопасные**
                    - **В параметрах запроса (URL или параметр запроса)** - Не безопасен, так как параметры запроса легко доступны для злоумышленников при уязвимости XSS.
                    - **В мета-теге** - Не безопасен, так как значение токена может быть доступно для сторонних скриптов через DOM.
        - `**HttpOnly**` флаг для куки
            - Не предотвращает атаку **CSRF** напрямую, так как джаваскрипт на другом домене (например, домен Б) **итак** не имеет доступа к кукам, установленным для домена А.
            - **Но позволяет избежать проблем с XSS-атакой кражи куков до этого (ранее), для последующей атаки**
        - Заголовок `**Referer**` - указывает с какой страницы был совершён переход или отправлена форма
            - Очень плох и слаб для защиты от **CSRF**-атак.
            - При создании **fetch** запроса можно указать своё значение заголовка, и оно будет отправлено таким (подделка)
            - Но может не отсылаться браузерами при формировании **fetch** запроса
            - Не посылается, если предыдущая страница **HTTPS**, а текущая **HTTP**
            - Исходный ресурс - не сайт, а файл
- **XSS** - Межсайтовый скриптинг (Cross-Site Scripting - XSS) - это уязвимость, при которой злоумышленник внедряет вредоносный код (обычно JavaScript) на веб-страницу, которая затем выполняется в браузере других пользователей, просматривающих эту страницу. Это может привести к краже данных пользователей, сеансов аутентификации, токенов, перенаправлению на вредоносные сайты, модификации самой страницы, или другим негативным последствиям.
    - **В зависимости от того, как вредоносный код попадает на страницу и где он выполняется, выделяют три основных типа XSS:**
        - **Хранимый (Persistent) XSS:**
            - Также известен как "стойкий XSS" или "XSS с хранением".
            - **Вредоносный код внедряется в базу данных или хранилище, например, комментарии на форуме или сообщения в блоге.**
            - Когда другой пользователь просматривает содержимое (например, комментарий, который отображает данные “как есть” без дополнительной фильтрации), вредоносный код выполняется в его браузере.
            - Этот тип XSS опасен, так как вредоносный код сохраняется на сервере и может влиять на всех пользователей, которые просматривают зараженный контент.
        - **Нехранящийся (Reflected) XSS:**
            - Также известен как "отраженный XSS" или "XSS с отражением".
            - **Вредоносный код внедряется в URL или параметры запроса, а затем отображается на странице,** например, в результатах поиска или в ссылках.
            - Когда пользователь переходит по такой ссылке или отправляет запрос с вредоносными параметрами, код выполняется в его браузере.
            - Этот тип XSS опасен, когда злоумышленник распространяет вредоносные ссылки и приманивает пользователей на злонамеренные сайты.
        - **DOM-основанный XSS:**
            - **Вредоносный код внедряется в клиентскую часть страницы и выполняется внутри DOM (Document Object Model).**
            - Этот тип XSS не отправляет данные на сервер, а непосредственно воздействует на отображаемую страницу.
            - Уязвимость связана с тем, что веб-приложение не адекватно обрабатывает пользовательский ввод при создании динамического контента.
    - **Общими правилами при работе с этими типами уязвимостей будет:**
        - **Обработка пользовательского контента как при вводе, так и при выводе.** При вводе - чистить получаемые данные, при выводе - санитайзить получаемые данные.
            - Экранирование, валидация, аккуратное использование innerHTML, санитайз, дополнительные либы для обнаружения SQL-инъекций
        - **Прятать куки** за **httpOnly.** Не устраняет XSS, но позволяет обезопасить сами куки от кражи, если **XSS**-атака всё же будет произведена
        - **Использование Content Security Policy (CSP) с директивой** `**reflected-xss block**`- что бы в принципе ограничить возможность загрузки данных (скриптов) из других источников. Также для запрета использования `**eval()**` и `**Function()**` . Ограничивает загрузку страницы, если видит возможные угрозы для **XSS-атак. Дополнительный уровень защиты**
        - **Использование заголовка X-XSS-Protection** в ответе. Останавливает загрузку страницы, если видит что есть XSS-уязвимость. **Не требуется при наличии грамотно настроенного CSP**
        - **Использование заголовка X-Content-Type-Options** в ответе. Если **nosniff** (по дефолту) изменить на true, то браузер не будет пытаться исправить или определить самостоятельно **MIME-типе** файла, и запустить его. Например, указан текст (или не указано ничего) и браузер пытается пытается определить тип, заглядывая внутырь. Таким образом можно скрытно подсунуть скрипт. **Конкретно эта вещь помогает от встраиваемых изображений с потенциально скрытым кодом внутри них. Не требуется при наличии грамотно настроенного CSP**
        - **Поддерживать библиотеки в актуальном состоянии** (они фиксят ошибки внутри себя)
- **Clickjacking** - перехват кликов пользователя, с целью обманов заставить его совершить действие
    - Пример возможного поведения:
        1. Злоумышленник создает скрытый **iframe на своей странице** и загружает в него страницу **"bank.com",** на которой находится платежная форма.
        1. Затем злоумышленник создает свои элементы (например, невидимую кнопку) на своей странице, которые точно соответствуют кнопке "Сделать платеж" на странице **"bank.com".**
        1. С помощью CSS стилей или других методов, злоумышленник скрывает **iframe** за своими элементами, так что пользователь не видит **iframe**.
        1. Пользователь заходит на страницу злоумышленника и, не подозревая обмана, кликает на невидимую кнопку.
        1. На самом деле этот клик перенаправляется на скрытый **iframe**, и платежная форма на сайте **"bank.com"** выполняется от имени пользователя, в результате чего деньги переводятся без его ведома.
    - **Защита - по сути, только одного типа: запретить или ограничить встраивание сайта через iframe на другие сайты**
        - **X-Frame-Options или CSP frame-ancestors**: Установка заголовка X-Frame-Options на сервере или использование CSP директивы frame-ancestors позволяет предотвратить встраивание вашего сайта в iframe на сторонних страницах. Это поможет предотвратить Clickjacking на уровне браузера.
        - **Кастомные самописные штуки по определению** того, открыт ли сайт в айфрейме, и как это в дальнейшем обрабатывать
- **SQL** - напрямую запросы в базу. На клиенте нет смысла пытаться обезопасить. **Надо на беке. ORM спасает частично**
- **noSQL** - для не sql баз данных. **Тоже бековая тема. ORM спасает частично**
- **LDAP** - исполнение кода на беке. Работает на своём протоколе. **Чисто бековая тема.**
- **XPath** - уязвимость в запросах XPath. **XPath** - язык, используемый для выбора и фильтрации данных в XML-документах, и обычно используется в веб-приложениях для извлечения информации из источников XML-данных. **Как бы бековая**
- **Не столько уязвимости, но вещи, о которых нужно помнить**
    - **POR** - **Предсказуемые идентификаторы объектов (Predictable Object References)**
    - **DDoS** - дддудудос-дудудуудудос!
    - **Использование устаревших компонентов и библиотек** (Outdated Components)
    - **Открытые точки доступа к API** (не закрытые за авторизацией)
    - **Отсутствие или недостаточность валидации ввода пользователем**
- Дополнительно статьи по теме
    - [https://www.dev-notes.ru/articles/security/xss-dangling-markup/](https://www.dev-notes.ru/articles/security/xss-dangling-markup/)
    - [https://www.dev-notes.ru/articles/security/csrf-bypassing-token-validation/](https://www.dev-notes.ru/articles/security/csrf-bypassing-token-validation/)
    - [https://www.dev-notes.ru/articles/security/clickjacking/](https://www.dev-notes.ru/articles/security/clickjacking/)
    - [https://www.dev-notes.ru/articles/security/csrf-bypassing-referer-based-defenses/](https://www.dev-notes.ru/articles/security/csrf-bypassing-referer-based-defenses/)

### Механизмы защиты в вебе:

**Перечень:**

- **Same Origin Policy (SOP)**
- **Cross Origin Resource Sharing (CORS)**
- **Content-Security-Policy (CSP)**
- **HTTP Security Headers**

**Описание:**

- **Same Origin Policy (SOP).**
    - **Встроенная в браузеры политика, не настраивается дополнительно**
    - Политика, запрещающая кроссдоменные запросы. Запрет с целью обезопасить пользователя от возможных угроз от раздачи чувствительных данных на другие домены (чужие)
    - Запрещает запросы к источникам (origin) отличным от того, с которого была загружена текущая страница (в контексте которой производится новый кроссдоменный запрос)
    - Внедрена была очень давно, как необходимое ограничение.
    - **Общий смысл таков:**
        - **Основная цель** - запрет на пересылку потенциально чувствительных данных с одного домена на другой. Таким образом защищает от того, что пользовательские данные могут быть пересланы с текущего сайта на опасный (например, встроенным скриптом, собирающим текущие куки, и отправляющим их как простой текст на сторонний сайт - кража кук)
        - **Само по себе это полезно, но раскрывается это при XSS-атаках,** или при ошибочных действиях (админ нечаянно добавил кривой скрипт, или в подключенной бибилиотеке подменили скрипт в зависиомстях), В любом из этих случаев, на странице могут появиться проблемы (попытки своровать чувствительные данные), но благодаря SOP эти данные просто не получиться отправить на другие домены.
        - **Можно сказать, что SOP снижает возможные последствия XSS-атак и других кривых действий, хоть и не предупреждает их изначально.**
    - Поведение:
        - В целом, все взаимодействия относятся к одному из трёх типов:
            - **Запись** - преход по ссылкам, редиректы, сабмит форм
            - **Встраивание** - вставка контента, картинок, стилей и т.д. на страницу
            - **Чтение** - чтение ответов на запросы
        - По умолчанию запрещается **Чтение** - вызовы к другим ориджинам из скриптов (позволяющие передать данные на другой ориджин), но при этом позволяется встраивание контента на страницу с других источников:
            - JavaScript с помощью элемента `**<script src="..."></script>**`.
            - CSS с помощью элемента `**<link rel="stylesheet" href="...">**`.
            - Изображения с помощью элемента `**<img>**`.
            - Медиа (видео и аудио) с помощью элементов `**<video>**` и `**<audio>**`.
            - Внешние ресурсы, встроенные с помощью элементов `**<object>**` и `**<embed>**`.
            - Шрифты, применяемые с помощью `**@font-face**`.
- **Cross Origin Resource Sharing (CORS).**
    - Политика кроссдоменного доступа к ресурсам
    - Была внедрена для того, что бы можно было передавать данные между сервисами и сайтами на различных доменах
    - Позволяла переопределять строго поведение механизма **SOP**, и настраивать разрешения на кросдоменные запросы
    - **Механизм работы:**
        - На целевых серверах настраивается перечень правил через заголовки, и благодаря этому:
            - Браузер клиента, запустив запрос, получает ответ о том, можно ли получать контент с внешнего сайта (полезно когда юзера атакую и с подложной страницы отправляют запрос в его сайт-банк)
            - Сервер сам определяет каким источникам он может давать доступ к своему контенту. Кому дать а кому запретить
    - **Хорошая идея, но имеет проблемы:**
        - Сложность настройки и управления правилами (не забывать обо всех возможных запросах в браузерах)
        - Создавалась для улучшения SOP, но по итогу с плюсами (разрешением кроссдоменных запросов) принесла и проблемы (скрипты могут воровать данные и отсылать данные на левые сервера, у которых корсы настроены открыто). И корсы, по сути, просто открывают возможность таких запросов и не способны ограничивать их.
            - **И это главная проблема корсов, потребовавшая придумывать дополнительные механизмы и политики безопасности (CSP)**
- **Content-Security-Policy** - новый механизм, описывающий политику контента (правила и ограничения) по загрузке контента и его использования для страницы: откуда загружать, как использовать, какие ограничения
    - Помогает в защите от **Clickjacking и XSS-атак.**
        - Ограничивает источники загрузки контента (скриптов и изображений (со скрытыми скриптами в них) ) - `**script-src 'self' https://example.com**`
        - Запрещает загрузку скриптов со сторонних, не разрешённых доменов, и совершение запросов к таким доменам из скриптов на странице
        - Запрещает встраивание сайта в айфрейм `**frame-ancestors 'none'**`
    - Определяет правила через HTTP-заголовки
    - Описывает политику для каждой страницы (и для всех запросов в рамках неё)
    - Позволяет гибко настроить (а иногда и отключить) свои политик для содержимого
    - При нарушениях CSP - отправляет отчёты об этом на сервер
    - Директивы для указания источников: `**default-src**`, `**script-src**`, `**style-src**`, `**img-src**`, `**font-src**` , `**connect-src**` , `**child-src**` и т.д.
        - **Например**:
            Content-Security-Policy:
            default-src 'self';
            connect-src 'self' [https://api-domain-1.com](https://api-domain-1.com/) [https://api-domain-2.com](https://api-domain-2.com/);
            media-src 'self' [https://media-domain-1.com](https://media-domain-1.com/);
            frame-ancestors 'self';
            form-action 'self' [https://form-action-domain.com](https://form-action-domain.com/);
            manifest-src 'self' [https://manifest-domain.com](https://manifest-domain.com/);**И другие**

    - Штука годная и нужная, **но не защищает на 100% по умолчанию.** **По умолчанию, если (CSP) не настроена или включена с директивой** `**default-src 'self';**`, она применяется только к исполняемым ресурсам, таким как скрипты и стили, но **не ограничивает загрузку изображений с внешних доменов.**
        Если изображения загружаются с внешних доменов, то них это ограничение не распространяется. Если изображение содержит вредоносный скрипт (например, скрытый JavaScript код), он будет выполнен в контексте страницы и может представлять опасность для безопасности.**Зловред может быть спрятан в изображении, и загружен другими пользователями при попытке открыть это изображение. Ограничение на источники загрузки изображений позволяют избежать таких проблем - ЭТО ПРИМЕР ЗАЩИТЫ ОТ XSS-атаки**

- **HTTP Security Headers** - это целый набор HTTP-заголовков, которые настраивают и обеспечивают безопасность веб-ресурса для пользователей. Их цель в настройке клиента, формировании набора правил устраняя потенциально возможные проблемы и риски связанные с атаками, шарингом чувствительных данных и т.д.
    - Представляет собой группу отдельных заголовков, каждый из которых позволяет настроить свои политики безопасности для контента на странице:
        1. **Strict-Transport-Security (HSTS)**: Указывает браузеру использовать только безопасное соединение (HTTPS) при взаимодействии с веб-сайтом в течение определенного периода времени.
        1. **Content-Security-Policy (CSP)**: Позволяет установить политику контроля над тем, какой контент может быть загружен и выполнен на странице.
        1. **X-XSS-Protection**: Включает механизмы защиты от XSS в некоторых современных браузерах.
        1. **X-Frame-Options**: Предотвращает кликджекинг, запрещая загрузку страницы во фрейм или iframe.
        1. **X-Content-Type-Options**: Предотвращает некоторые виды MIME-сниффинга, когда браузер пытается интерпретировать содержимое файла с неправильным типом MIME.
        1. **Referrer-Policy**: Контролирует, какая информация о реферере отправляется с запросами на другие сайты.
        1. **X-Download-Options**: Предотвращает некоторые виды атак, связанных с загрузкой файлов.
        1. **X-Permitted-Cross-Domain-Policies**: Устанавливает политику, определяющую, какие кросс-доменные политики разрешены для сайта.
        1. **X-Powered-By**: Удаляет информацию о используемой технологии сервера из HTTP-ответа для снижения риска для безопасности.
        1. **Expect-CT**: Позволяет серверу сообщить о том, что он поддерживает проверку цепочки сертификатов и может запрашивать отчеты о нарушениях.
        1. **Feature-Policy**: Позволяет управлять доступом к определенным веб-платформам и функциям браузера.
        1. **Public-Key-Pins**: Позволяет серверу сообщить о том, какие открытые ключи публичных ключей необходимо проверить в будущем.
        1. **Content-Disposition**: Управляет тем, как браузер должен обрабатывать содержимое, которое было отправлено с сервера.
        1. **Access-Control-Allow-Origin**: Определяет, какие источники могут получать доступ к ресурсам на сервере через CORS.
        1. **Access-Control-Expose-Headers**: Определяет, какие заголовки могут быть доступны клиентам при использовании CORS.

### Почитать

[https://frontend.tech-mail.ru/slides/s4/](https://frontend.tech-mail.ru/slides/s4/)

- [x] Дебагинг
    1. ~~Штука очень мощная, и кратно пизже всяких консоль логов, но и по сложнее будет~~
    1. ~~Различные форматы отладки, лайв-режим, просмотр содержимого всех значений, просмотр лайв-выражений (А+В: С)~~
    1. ~~Дебажить с различными подходами (построчно с проваливанием, построчно без проваливания в вызовы методов, шаг до выхода из стека (откуда вызвано)~~
    1. ~~Можно править код на ходу. Как сам код, так и вычисленные значения~~
    1. ~~Во время остановки кадра, можно иметь доступ к коду в стеке через консоль. Консоль как бы всегда привязана к активному контексту исполнения~~
- [x] HTTP/3 - окло 30% современного траффика
- [x] Воркеры. Есть несколько видов воркеров. Их смысл в создании отдельного контекста, в котором в отрыве от основного можно было бы выполняться некоторые операции
    - [x] **Сервис-воркеры.** Изначально создавались как замена **AppCache**, что бы иметь возможность работать с приложениями при нестабильных соединениях, **и даже в офлайн-режиме.** У неё более широкий диапазон возможностей и методов по управлению кешированием ранее загруженных данных.**Работает по принципу мидлвары** - на границе между приложением и сетью, пробрасывая все запросы в обе стороны
        На данный момент, в основном используется как основа для Progressive Web Application. Позволяет устанавливать сайты на устройство как мобильные приложения (с рядом ограничений, но всё же)

    - [x] **Веб-воркеры.** Отдельный поток выполнения, в котором можно располагать сложные и тяжёлые вычисления, которые бы не блокировали основной поток. Позволяют общаться с основным контекстом методом служебных сообщений
- [x] **Кеширование**
    - [x] Управляется через заголовки запросов и ответов. В основном, клиент срашивает, сервер отдаёт директивы-указания
    - [x] Множество различных стратегий управления кешированием на сайтах. По времени жизни (с какого момента или сколько именно), по факту изменения ресурса (изменяется название, что бы url ресурса стал другим) и т.п.
    - [x] Фреймворки налаживают самостоятельно, и достаточно оптимально. На серваках с контентом нужно делать самому
    - [x] Кешируются только GET и HEAD запросы, всё остальное нет
    - [x] Для ревалидации кеша, при каждом запросе, даже если есть кеш, запрос всё равно улетает на сервер, и от него уже приходят либо подтверждения того, что кеш актуален (204 Not modified) либо обновлённый ресурс (который замещает собой предыдущий кеш этого ресурса)
- [x] Приоритезация в запросах
    - [x] HTTP/2 - на основе весов. Страница, для её ресурсов отдельные запросы, строится 256-значное дерево, с взаимно-зависимым распределением весов в нём. Запросы приоритезируются относительно друг друга.
    - [x] HTTP/3 - на основе нового подхода, с указанием веса в 8 ед. и возможностью паршиал доставки контента. Чем меньше вес, тем приоритетнее запрос
    - [x] И в том и другом запросе, атрибуты загрузки ресурсов (defer, preload и другие) влияют на приоритеты запросов.
    - [x] Значений приоритетов либо в заголовках запросов/ответов, либо во фреймах
- [x] API работы с навигацией
    - [x] **Navigation API** - непосредственно сама навигация.
        - [x] Современный способ работы с навигацией на странице (нацелен на потребности СПА)
        - [x] В SPA шаблон страницы, как правило, остается неизменным во время использования, а содержимое динамически переписывается по мере того, как пользователь посещает разные страницы или функции. В результате в браузере загружается только одна отдельная страница, что нарушает ожидаемый пользовательский опыт перехода туда и обратно между различными местами в истории просмотров. Эту проблему можно частично решить с помощью [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) , но он не предназначен для нужд SPA. API навигации призван восполнить этот пробел.
    - [x] **History API** - доступ к истории текущей сессии браузера. Предоставляет полезные методы и свойства, которые позволяют переходить назад и вперёд по истории пользователя и манипулировать её содержимым.
    - [x] **Location API** - работа с текущим местонахождением (параметры)
- [x] Токены, регистрация и авторизация в приложениях. JWT
    - [x] Потом ещё и авторизация через провайдеров (гугл, фейсбук и прочее)
- [x] Оптимизация сайтов
    - [x] По скорости
    - [x] По размеру страниц
    - [x] Отложеная загрузка модулей
    - [x] По производительности (ключевые метрики, механика работы браузера и т.д.)
- [x] Принцип работы браузера
    - [x] Что происходит после ввода адреса в браузер **(Конспект)**
    - [x] Как браузер парсит страницу и как это влияет на отображение страницы
        - [x] Механизм рендеринга страницы. Ключевые узкие места. ДОМ СИЭСЭСОМ и как они мержаться друг на друга
        - [x] [https://webdevblog.ru/kak-brauzer-renderit-veb-stranicu/#:~:text=Механизм рендеринга проходит дерево рендеринга,макете отрисовать пиксели на экране](https://webdevblog.ru/kak-brauzer-renderit-veb-stranicu/#:~:text=%D0%9C%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC%20%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%D0%B0%20%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B8%D1%82%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%20%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%D0%B0,%D0%BC%D0%B0%D0%BA%D0%B5%D1%82%D0%B5%20%D0%BE%D1%82%D1%80%D0%B8%D1%81%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%BF%D0%B8%D0%BA%D1%81%D0%B5%D0%BB%D0%B8%20%D0%BD%D0%B0%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B5).
    - [x] Какими образом подгружаются скрипты и стили, асинхронно или нет. Блокируют или нет процесс рендеринга. Как сделать так, что бы не блокировали?
    - [x] Какие движки используются. Насколько сейчас необходима и важна кроссбраузерная вёрстка. Каким образом решается
        - [x] Самыми популярными движками на данный момент являются:
            - [x] **Blink** - используется в браузерах **Google Chrome, Microsoft Edge, Opera** и других.
            - [x] **WebKit** - используется в браузере **Safari** на мобильных и настольных устройствах от **Apple**.
                1. На десктопах и ноутбуках **Mac** используется движок **WebKit**, в то время как на мобильных устройствах iOS используется более усовершенствованная версия **WebKit** - **WKWebView**.
                1. Так же, все сторонние браузеры используют этот движок для работы на **IOS. Например, Google Chrome так же использует WebKit в качестве движка на IOS**
            - [x] **Gecko** - используется в браузере **Firefox** и некоторых других.
        - [x] **Blink** является форком **WebKit**, который был создан Google после разрыва с Apple. **Microsoft Edge** также использует **Blink**, начиная с версии 79.
        - [x] **WebKit и Blink** основываются на языке программирования C++ и являются открытыми проектами, поэтому любой желающий может использовать их код для создания собственных браузеров. **Gecko** является частью проекта Mozilla и также является открытым проектом.
    - [x] Все варианты сохранения пользовательских данных в браузере
        - [x] Заголовки
            - [x] Куки - фрагменты спец. данных, хранимые в заголовках запросов, и имеющие АПИ для работы с ними
        - [x] Все виды хранилищ: LS / SS
- [x] Событийная модель
- [x] Посмотреть какой движок сейчас используется в браузерах. Что там с политикой одного движка на айос? Это везде или только на айфонах так? Какие-то изменения планируются в этом? Какие? Как это влияет на кроссбраузерную вёрстку. Требуются ли для этого полифилы JS? А полифилы для вёрстки? Если двжиок один и тот же, но поверх натягивается другой UI, то полифилы для какого движка им нужны?
    - [x] Про работу нового кода на старых платформах. Общая проблема - не все среды обеспечивают возможность работы последних фичей JS. И есть два основных способа исправить ситуацию:
        - [x] **Транспиляция**. **Даунгрейд** версии языка, при котором **async await** даунгрейдятся до **промисов**, а **for..in и for..of** до **простых циклов**
        - [x] **Полифилы**. Способ предоставления альтернативной реализации. Это, фактически, переписывание кода, но не просто переписывание, а через добавление полифилов - написание **другого кода**, что бы по итогу получить такой же функционал.

            **В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.**

            **Полифил** – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.

            Тогда мы можем реализовать его сами и добавить во встроенный прототип.

            Например:

            `if (!String.prototype.repeat) { // Если такого метода нет // добавляем его в прототип String.prototype.repeat = function(n) { // повторить строку n раз // на самом деле код должен быть немного более сложным // (полный алгоритм можно найти в спецификации) // но даже неполный полифил зачастую достаточно хорош для использования return new Array(n + 1).join(this); }; } alert( "La".repeat(3) ); // LaLaLa`

- [x] В каких форматах пересылаются данные?
    - - [x] **На фронт принимаются в:**

            `[Response.arrayBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer)` - Returns a promise that resolves with an `[ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)` representation of the response body.

            `[Response.blob()](https://developer.mozilla.org/en-US/docs/Web/API/Response/blob)` - Returns a promise that resolves with a `[Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)` representation of the response body.

            `[Response.clone()](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone)` - Creates a clone of a `Response` object.

            `[Response.formData()](https://developer.mozilla.org/en-US/docs/Web/API/Response/formData)` - Returns a promise that resolves with a `[FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)` representation of the response body.

            `[Response.json()](https://developer.mozilla.org/en-US/docs/Web/API/Response/json)` - Returns a promise that resolves with the result of parsing the response body text as `[JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)`.

            `[Response.text()](https://developer.mozilla.org/en-US/docs/Web/API/Response/text)` - Returns a promise that resolves with a text representation of the response body.

            Либо просто прямая ссылка на файл, находящийся на сервере

        - [x] **С фронта отправляются в:**
            - [x] **formData** - для пересылки данных формы (и не только) в теле запроса. Может включать бинарные данные **(отправлялось - 1: 123, 2: 123)**

                POST /todos HTTP/1.1
                Accept-Encoding: gzip, deflate, br
                Connection: keep-alive
                `Content-Type: multipart/form-data; boundary=--------------------------625769445081173934721930`
                Content-Length: 28295

                `---------------------------625769445081173934721930 Content-Disposition: form-data; name="1"`

                `123 ----------------------------625769445081173934721930 Content-Disposition: form-data; name="2"`

                `123 ----------------------------625769445081173934721930 Content-Disposition: form-data; name="3"; filename="image_2021-04-06_15-01-09.png" Content-Type: image/png`

                `�PNG ��� IHDR�����q��� j���� pHYs�������+�� �IDATx���{\W�7��Y4$/'"AV����d�N���r1&��! ChB.���(�v� h��n��Ʌ�H�3q��䁄͘q���5�,hgy�@�����]]�Kw!?`

                `………………………………………. ��������0��5������j��4�(����IEND�B� ----------------------------625769445081173934721930--`

            - [x] **x-www-form-urlencoded** - так же пересылка данных формы, но без файлов. Дополнительно кодирует в **url-безопасный текст**, но пересылает данные так же в теле самого запроса. Уже практически повсеместно заменён на formData, но по прежнему так же может быть использован **(отправлялось - 1: 123 123, 2: 123 123)**

                ==POST /todos HTTP/1.1
                Accept-Encoding: gzip, deflate, br
                Connection: keep-alive
                ====`Content-Type: application/x-www-form-urlencoded`====
                Content-Length: 26==

                ==`1=123%20123&2=123%20123`==

            - [x] **JSON** - Для передачи каких-либо пользовательских данных. Просто удобный контейнер

                ==POST /todos HTTP/1.1
                ====`**Content-Type: application/json**`====Host:== ==[jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com/)====
                Accept-Encoding: gzip, deflate, br
                Content-Length: 32==

                ==…..==

                ==`{"1": "123", "2": 123}`==

            - [x] **BinaryFiles** - Изображения, видео и любые другие файлы

                POST /todos HTTP/1.1
                Accept-Encoding: gzip, deflate, br
                Content-Length: 27866
                `Content-Type: image/png`

                `<Binary Image>`

            - [x] **QueryParams** - Параметры: опции, фильтрации, сортировки, офсеты, лимиты и прочее. Либо мелкие фрагменты пользовательских данных. Либо как хранилище, по которому можно восстановить состояние страницы

                POST `/todos?1=123&2=456 HTTP/1.1`
                Accept-Encoding: gzip, deflate, br
                Connection: keep-alive
                Content-Length: 0

            - [x] **Headers** - Авторизация, техническая информация, дополнительные данные о токенах, ключах запросов, идемпотентности и прочем

                POST /todos HTTP/1.1
                `Authorization: 123123123 CSRFToken: eegrgergebtynyunthnt idempotenceKey: csdcsg534r24t7`
                Accept-Encoding: gzip, deflate, br
                Connection: keep-alive
                Content-Length: 0

## React ()

- Открытые вопросы (без ответа)

### Версия 19 - изменения

- [ ] **Компайлер** - автоматически автоматизирует вопросы связанные с повторными рендерингами. Потенциально можно отказаться от мемоизации
- [ ] **ref**- как пропс
- [ ] Контекст - просто как провайдер. Не обязательно использовать через точку
- [ ] **Actions** - специфичная штука, вариант описания логики связанной с бекендом. Сильно специфична. Очень. Из преимуществ - какие-то асинхронные тяжёлые вещи. Но юзать везде и всюду - это негативно
- [ ] Декларативный способ указать preload для ресурсов. Больше доступа к этому через либу react-dom, вместо использования плагинов для бандлеров
- [ ] **Три новых хука.**
    - [ ] `**useFormStatus**`**,** `**useOptimistic**`**,**`**useActionState**`
    - [ ] Для работы с формой и **optimisticUI**. В целом... ну неплохо. Очень частая фича, которую завезли в коробку. А так, подобный подход везде и всюду, имеется примерно в каждой первой либе про взаимодействие по сети.
    - [ ] Юзать просто так - ну тут как с хуками для формы: реализуемо? - Да. Будут ли юзать - ну сильно редко. Зачастую это будут либы готовые, а там всё лежит рядом и по функционалу с возможностью управления там побогаче. Штука норм, но чаще всего будут юзать другое.
    - [ ] Да и в целом, видел пару обсуждений о том, что оптимистик - не так часто уж и нужен. Только для вот таких маленьких действий. Это не решение для всего интерфейса, а только для уведомляшек, каунтеров и прочих флагов
- [ ] **Директивы. 'use client' и 'use server' - серверные компоненты**
- [ ] **Готовые компоненты title и meta для html**. ЭТО ХОРОШО. Удобно и полезно. Пока потенциальные сложности с порядком переопределения и возможных багов с тем, какой порядок переопределения будет, но думаю быстро порешается, и будет ок
- [ ] **Интеграция с веб-компонентами**. Возможность подключить веб-компоненты и управлять ими
- [ ] **Хук use** - универсальная обёртка для работы с асинхронностью, промисами. Взаимодействовать с ним, как с асинхронным контролируемым истоником данных. + ЧТО ОЧЕНЬ ХОРОШО - он работает с Саспенсом. Пока не разрезолвится, будет корректно отображать фолбек. + может принимать в себя контекст
    - [ ] Но немного меняет концепцию использования и работы с хуками. Что можно использовать внутри условных конструкций, и доступ к контексту. Много плюсов, но необходимо немного менять мышление
- [ ] **Активити** - тоже, своеобразная штука. Явное сокрытие компонентов, без удаления из реакт WIP-tree. Компонент есть, внутри реакта, уже просчитан, хранится в памяти, но в DOM его нет. Есть кейсы, можно юзать, но сходу... Надо посмотреть на бест-практисы применения, что бы не тащить его сразу всюду, а то можно отрендерить всё приложение фоном и там оно будет крутится невидимо. Норм, но надо смотреть. Тоже немного меняет майнд-сект по разработке на реакте

---

### Версия 18 - изменения

- [ ] **Automatic batching -** (Автоматическая пакетная обработка)
    - [ ] **React группирует несколько обновлений состояния в один повторный рендеринг для повышения производительности**. раньше это работало только внутри обработчиков событий React.
    - [ ] **Обновления внутри промисов, setTimeout, собственных обработчиков событий или любых других событий** по умолчанию не пакетировались в React. **Теперь же,** при пакетной обработке **эти обновления будут группироваться автоматически**
    - [ ] Ранее - объединялось последовательное обновление состояния только в React-обработчиках

    ```JavaScript
    function handleClick() {
        setCount(c => c + 1); // Does not re-render yet
        setFlag(f => !f); // Does not re-render yet
        // React will only re-render once at the end (that's batching!)
      }
    ```

    - [ ] Но в других случаях пакетной обработки не применялось

    ```JavaScript
      function handleClick() {
        fetchSomething().then(() => {
          // React 17 and earlier does NOT batch these because
          // they run *after* the event in a callback, not *during* it
          setCount(c => c + 1); // Causes a re-render
          setFlag(f => !f); // Causes a re-render
        });
      }
    ```

    - [ ] Теперь же, аналогичный код будет выполнятся с пакетной обработкой - вместо 1 рендера на каждое изменение состояния, 1 рендер на весь пакет. И теперь это работает для **всех** обработчиков:
    - [ ] `function handleClick() {...}` ; `setTimeout(() => {...);` ; `elm.fetch(/*...*/).then(() => {...})` ; `elm.addEventListener('click', () => {...})`
- [ ] **Transitions** - (Переходы)
    - [ ] Подход к разделению событий: срочные и отложенные. **Срочные** - клик мыши по кнопке фильтра. **Отложенные** - показать отсортированный список. **Кнопка нажимается сразу**, **список рендериться с задержкой**

    ```JavaScript
    import { startTransition } from 'react';

    // Urgent: Show what was typedset
    InputValue(input);// Mark any state updates inside as transitions

    startTransition(() => {
    	// Transition: Show the results
    	setSearchQuery(input);
    });
    ```

    - [ ] Обновления, обернутые в **startTransition**, обрабатываются как **несрочные** и **будут прерваны**, если поступят более срочные обновления, такие как клики или нажатия клавиш. **Если переход прерывается** пользователем (например, путем ввода нескольких символов подряд), React удалит устаревшую работу по рендерингу, которая не была завершена, и будет рендерить только последнее обновление.
    - [ ] `useTransition`: хук для запуска переходов, включая значение для отслеживания состояния ожидания.
    - [ ] `startTransition`: способ запуска переходов, когда хук нельзя использовать.
- [ ] **React.StrictMode — инструмент для обнаружения потенциальных проблем в приложении. Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.**
    - [ ] Находит несколько видов потенциальных проблем, наиболее актуальными из которых является помощь в обнаружении неожиданных побочных эффектов

    Строгий режим не способен автоматически обнаруживать побочные эффекты, но помогает их отследить, сделав более **детерминированными**. Такое поведение **достигается путём двойного вызова** следующих методов:

    - Методы `constructor`, `render`, и `shouldComponentUpdate` классового компонента
    - Статический метод классового компонента `getDerivedStateFromProps`
    - Тело функционального компонента
    - Функции обновления (первый аргумент `setState`)
    - Функции, переданные в `useState`, `useMemo`, или `useReducer`
    - [ ] Поскольку вышеупомянутые методы могут быть вызваны более одного раза, важно, чтобы они не приводили к каким-либо побочным эффектам. Игнорирование этого правила может привести к множеству проблем, включая утечки памяти и недопустимое состояние приложения.
    - [ ] Строгий режим может быть включён для любой части приложения.
    - [ ] С 17-ой версии удаляется дублирование логирования. **Starting from React 18, React does not suppress any logs. However, if you have React DevTools installed, the logs from the second call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.**
    - [ ] **с 18-ой версии дублирование вернулось, но дубли затеняются цветом**
    - [ ] Одной из будущих особенностей и фичей, которые будут проверяться в стрктМоде - это возможность восстановления состояния после повторного монтирования компонента (что при повторном монтировании всё останется таким же, как и при первом монтировании). Для этого, уже сейчас планируется в дев режиме использовать перемонтирование компонента сразу же, при его создании: создали, и сразу же удалили и вновь создали, что бы проверить что при таком сценарии компонент всегда возвращает одно и то же. Без этого нет гарантии, что в будущем такие компоненты не сломаются в сценарии, когда пользователь открыл страницу, из неё перешёл в другую и вернулся назад - нет гарантии что восстановленный компонент корректно отрисуются повторно
        - [ ] _В будущем мы хотели бы добавить функцию, которая позволяет React добавлять и удалять разделы пользовательского интерфейса с сохранением состояния. Например, когда пользователь переходит от экрана к экрану и обратно, React должен иметь возможность немедленно отображать предыдущий экран. Для этого React поддерживает повторное монтирование деревьев с использованием того же состояния компонента, которое использовалось до размонтирования._
        - [ ] **Надо подумать как это может отразиться на размещении логики в хуках**

    Размонтирование и повторное монтирование включает в себя:

    - `componentDidMount`
    - `componentWillUnmount`
    - `useEffect`
    - `useLayoutEffect`
    - `useInsertionEffect`
    - [ ] **Новые проверки в StrictMode**
        - [ ] Проверка на корректность поведения хуков. В будущем планируется существенно улучшить и оптимизировать работу с компонентами и страницами - иметь возможность быстро восстанавливать удалённые ранее компоненты из DOM. Для того, что бы это корректно работало, добавлены соответствующие проверки: при каждом рендеринге, после монтирования компонента, они его демонтируют и монтируют заново, что бы проверить идемпотентность поведения компонента (сколько бы раз ни показывали - всегда будет одно и то же). Сейчас же есть проблема, что пользователи реализуют не идемпотентное поведение в хуках, и это проблема для такой оптимизации (размещение автоматической логики и фетчинга данных в хуках)
- [ ] **Новые хуки**
    - [ ] `useTransition` - (для состояния) пометить некоторые обновления состояния как **несрочные**. **Другие обновления состояния по умолчанию считаются срочными**. **React** позволит **срочным обновлениям** состояния (например, обновлению ввода текста) **прерывать несрочные обновления состояния** (например, отображение списка результатов поиска)
    - [ ] `useId` - генерация ключей для либ (консистентность данных на рендер-беке и фронте)
    - [ ] `useDeferredValue` - (для рендеринга) позволяет отложить рендеринг на попозже (даёт ему низий приоритет). Позволяет избежать проблемы с синхронным блокированием стека выполнения из-за синхронной реакции на произошедшие изменения. Хук позволяет сделать изменения зависимые от него малоприоритетными, и выполняемые в свободное (для брузера) время
    - [ ] `useSyncExternalStore` - (по сути, только для библиотек, а не для пользователей) это новый хук, который позволяет внешним хранилищам поддерживать параллельное чтение, заставляя обновления в хранилище быть синхронными. Он устраняет необходимость в useEffect при реализации подписок на внешние источники данных и рекомендуется для любой библиотеки, которая интегрируется с состоянием, внешним по отношению к React.
    - [ ] `useInsertionEffect` - (по сути, только для библиотек, а не для пользователей) новый хук, который позволяет библиотекам CSS-in-JS решать проблемы с производительностью при внедрении стилей при рендеринге.
- [ ] **Динамический импорт и React.lazy**
    - **Динамический импорт** — это чистый JavaScript-механизм, который может использоваться для асинхронной загрузки любых модулей JS.
    - **React.lazy** — это React-абстракция над динамическим импортом, предназначенная исключительно для загрузки React-компонентов.

    **React.lazy** предоставляет более простой и декларативный способ для динамической загрузки компонентов в React-приложениях и требует использования **React.Suspense** для отображения запасного контента во время загрузки компонента.

    **Динамический импорт** - создаёт новый отдельный чанк с кодом компонента, а **lazy** оборачивает его, и позволяет удобно обрабатывать в **React** как динамическую подгрузку с фолбеком. Просто обёртка для реакта

    - Нужно это ещё и по тому, что при подгрузке отдельных чанков, их потребуется каким-то образом подключить к самому реакту. И **Lazy** позволит сделать это контролируемым образом
    - Так же, даже с обёрткой, всё равно остаётся возможность добавить комментарии на префетчинг данных-чанка, что позволит оптимизировать работу по загрузке данных

        ```JavaScript
        const HomePage = React.lazy(() => import(
        	/* webpackPrefetch: true */
        	'./pages/HomePage'
        ));
        ```

        ```JavaScript
        const AboutPage = React.lazy(() => import(
        	/* webpackPreload: true */
        	'./pages/AboutPage'
        ));
        ```

    - А прелоадинги нужны, поскольку они загружаются ещё до момента загрузки и запуска основной части приложения, после анализа которой станет понятно какие подмодули нужны основныму приложению здесь и сейчас. К этому моменту, эти модули уже будут предзагружены

### Версия 17 - изменения

1. **React.memo** - мемоизация компонентов. Позволяет кешировать компонент, если пропсы для него остаются неизменными. НО ЕСЛИ внутри себя компонент использует контекст или стор или чо-то ещё, то это не сработает. Нужно разлеить поставщика контента и отображение. И тогда кеширование отображения станет работать корректно.
    - [ ] Если пропсами для такого компонента являются объекты - то это самое лучше место для их мемоизации
1. **<Profiler>** - компонент для оценки рендера компонентов. Оборачивает фрагмент приложения и поставляет множество показателей для качественной оценки показателей рендера. Временные метки для оценки качества мемоизации и прочего.
1. **<Suspense>** - **в общем случае,** позволяет **отображать запасной вариант**, **пока требуемые элементы не будут готовы** к рендеру (в частном случае - пока не закончат загрузку - свою или сетевых запросов или т.п.).
    - [ ] Декларативный способ указать что показывать вместо компонента, пока он не готов (пока загружается модуль с ним, или он обновляется или загружает данные для себя)
    - [ ] Крайне важен для решения проблем с SSR. Раньше, нужно было сгенерить весь html (вместе с данными), и отправить его на клиент, и только потом можно провести гидратацию. Теперь же, можно слать с сервака по частям. Сперва готовые лёгкие фрагменты сгенерить и отправить, а тяжёлые сфолбечить на лоадеры и заглушки, пока не будет готов основной компонент. Когда сложный компонент будет готов, он отрендерится на серваке, и реакт пошлёт его на клиент, и сам добавит в нужное место. И ВСЁ ГОТОВО. Саспенс выступает инструментом прогрессивного SSR, которые призван улучшить UX пользователей и сгладить проблемы с проблемной генерацией на серваке, из-за которой приходится долго ждать контент на клиенте
        [https://github.com/reactwg/react-18/discussions/37](https://github.com/reactwg/react-18/discussions/37)

    - [ ] Так же, саспенс, благодаря своей архитектуре, положительно влияет и на гидратацию. Он позволяет разбить процесс гидратации на отдельные этапы, в результате чего приложение “оживает” на клиенте по частям, и части будут готовы раньше, чем если бы ожидалось всё сразу из-за одного медленного и тяжёлого компонента внутри. Можно разбить гидратацию на несколько этапов, что позволит выполнить их отдельно последовательно, и не заблочить стек вызовов большой длительной операцией. И может приоставнавливать работу, если клиент взаимодействует с чем-то на странице (приоритет работ).
        И даже выбор какой фрагмент быстрее гидратировать - будет зависеть от активности пользователя - куда он наводит мышкой, кликает, нажимает клавиши - всё это учитывается и обрабатывается с учётом приоритетов (синхронно и асинхронно) - [https://github.com/reactwg/react-18/discussions/130](https://github.com/reactwg/react-18/discussions/130)

    - [ ] Работает с **React.lazy**, **работает на сервере** и **другие возможности** связанные с **параллельным рендерингом (транзишенами)**

    ```JavaScript
    <Suspense fallback={<Loading />}>
      <SomeComponent />
    </Suspense>
    ```

    - [ ] **React автоматически** будет отображать **резервную загрузку** до тех пор, **пока не будет загружен весь код и данные, необходимые дочерним элементам**.
    - [ ] Автоматическое переключение на резервный контент сработает только для тех компонентов, которые поддерживают **Suspense**.
        - [ ] Пока поддерживается только компоненты подключаемые через **Lazy**
        - [ ] В будущем, планируется предоставить АПИ для разработчиков библиотек, а пока это есть только в **Next.js и других топах.**
        - [ ] В настоящий момент нет АПИ, которое позволяло бы пользоваться этой фичей в ручном режиме разработчику
    - [ ] По умолчанию все дерево внутри **Suspense** рассматривается как единое целое. Например, даже если _только один_ из этих компонентов приостановит ожидание каких-то данных, _все_ они вместе будут заменены индикатором загрузки:
    - [ ] Загрузку (и резервное отображение контента при этом) можно делать каскадной. Каждый лвл определяет свои границы ответственности.
    - [ ] Может многократно переключаться на фолбек, если целевой становится периодически не готовым. Например, когда за него заворачивают список с результатами загрузки данных
        - [ ] При этом, полноценно размонтирует компонент и вызовет очистку при повторном рендеринге
    - [ ] Может использоваться в купе с остальными методами по управления переходами для конструирования более сложного динамичного интерфейса
    - [ ] Также, позволяет обрабатывать ошибки на серваке (если упало там), и возвращать вместо ошибки фаллбек-компонент
1. **Lazy** - отложить загрузку кода компонента до его первого рендеринга.
    - [ ] [https://ru.reactjs.org/docs/code-splitting.html](https://ru.reactjs.org/docs/code-splitting.html)
    - [ ] Компонент с ленивой загрузкой должен рендериться внутри компонента `Suspense`, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента. Показывать лоадеры / спиннеры / скелетон / аналогичные компоненты-заглушки
    - [ ] `lazy`возвращает компонент React, который вы можете отобразить в своем дереве. Пока код для ленивого компонента все еще загружается, попытка его отрисовки будет _приостановлена._ **Используйте** `**[<Suspense>](https://react.dev/reference/react/Suspense)**`**для отображения индикатора загрузки во время загрузки.**

        ```JavaScript
        import React, { Suspense } from 'react';

        const OtherComponent = React.lazy(() => import('./OtherComponent'));

        function MyComponent() {
          return (
            <div>
              <Suspense fallback={<div>Загрузка...</div>}>
                <OtherComponent />
              </Suspense>
            </div>);
        }

        // В этом примере код MarkdownPreviewне будет загружен, пока вы не попытаетесь отобразить его.
        // Если MarkdownPreviewон еще не загружен, Loadingон будет показан на своем месте.
        ```

    - [ ] `load`: Функция, которая возвращает [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) или другой _объект_ (подобный Promise объект с `then`методом). React не будет вызывать `load`до тех пор, пока вы не попытаетесь отобразить возвращаемый компонент в первый раз. После того, как React сначала вызовет `load`, он будет ждать его разрешения, а затем отобразит разрешенное значение как компонент React. И возвращенный промис, и разрешенное значение промиса будут кэшироваться, поэтому React не будет вызывать `load`более одного раза. Если Promise отклоняется, React будет `throw`причиной отклонения для обработки ближайшей границы ошибки.
1. **useDeferredValue** - это React Hook, который позволяет отложить обновление части пользовательского интерфейса.
    - [ ] Возвращает отложенную версию значения, передаваемого в него при вызове
    - [ ] Важно использовать memo при работе с дочерними компонентами (defferedValue - всегда одно и тоже и за счёт этого и ест ьвыигрышь, а без мемоизации он потеряется)
    - [ ] Хорошо работает вместе с **<Suspense>**
    - **Повторный рендеринг фона,** вызванный `useDeferredValue`эффектами, **не срабатывает до тех пор, пока он не будет зафиксирован на экране.** Если повторный рендеринг фона приостанавливается, его эффекты будут запущены после загрузки данных и обновления пользовательского интерфейса.
    - **Нет фиксированной задержки, вызванной** `**useDeferredValue**`**самой собой. Как только React завершит первоначальный повторный рендеринг, React немедленно начнет работать над фоновым повторным рендерингом с новым отложенным значением.** Любые обновления, вызванные событиями (например, вводом текста), прерывают повторную визуализацию фона и получают приоритет над ней.
    - [ ] Другими словами, это дублируемое значение, отстающее от оригинального, и которое обновляется после того, как интерфейс будет полностью завершен рендеринг и рендеринг интерфейса, основанного на оригинальном значении.
    - [ ] Изменили оригинал ⇒ оригинал стригерил обновление ⇒ снова изменили оригинал ⇒ обновление ⇒ снова стригерил оригинал ⇒ обновление ⇒ обновление заврешено ⇒ обновляется дублированное значение ⇒ обновляется экран на базе продублированного значения
    - [ ] Поведение хука может сбивать пользователя из-за отсутствия явной индикации действующих процессов (пользователю показывается предыдущее значение, а под капотом формируется новое, но пользователь об этом не уведомляется). это можно пофиксить чем-то вроде:

        ```JavaScript
        <div style={{
          opacity: query !== deferredQuery ? 0.5 : 1,
        }}>
          <SearchResults query={deferredQuery} />
        </div>
        ```

    - [ ] Также можно использовать для непосредственной отсрочки тяжёлых вычислений. Когда на каждое действие требуется что-то пересчитать и показать, это позволит выполнять расчёты в гарантированно свободное время, и при этом не блочить интерфейс этими расчётами, потому что они могут свободно прерваться, в отличии от традиционного подхода с debounce, который так же отсрочивает выполнение, но всё равно блочит расчёт и не прерывает запущенный процесс

        ---

### Версия 16 - изменения

- [ ] **Хуки. В целом**
    - [ ] [https://www.npmjs.com/package/eslint-config-react-app](https://www.npmjs.com/package/eslint-config-react-app) - Новый линтовый пакет, с обновлённым набором правил и анальной карой для хреновых пользователей хуков
    - [ ] [https://github.com/prettier/eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) - Для избежания проблем в правилах между линтером и преттиером
- [ ] **В 16 версии произошло некоторое переосмысление хуков**
- [ ] **Хуки**, в целом, это один из двух видов событий в реакте: “истинные” события и Эффекты
    - [ ] **Истинные события** - это какое-то событие, вызывавшее собой фактическое взаимодействие с системой (клики, запросы к сети, логирование, ввод данных с клавиатуры и прочее)
    - [ ] **Эффекты** - это события, вызванные непосредственно изменениями в самом рендеринге, а не конкретными событиями. **Это значит, что есть обычный процесс выполнения скрипта, а есть дополнительный элемент - эффект, который реагирует на фактические изменения в рендере**
    - [ ] **События** - **создаются**, **Эффекты** - **реагируют** на последствия событий. **Отправка сообщения в чат является** _**событием**_ , потому что оно напрямую вызвано нажатием пользователем определенной кнопки. **Однако установка соединения с сервером является** _**Эффектом**_, поскольку она должна происходить независимо от того, какое взаимодействие вызвало появление компонента. **Большинство эффектов** запускаются **в конце коммита [после](https://react.dev/learn/render-and-commit) обновления экрана**. Это хорошее время для синхронизации компонентов React с какой-либо внешней системой (например, сетью или сторонней библиотекой).
    - [ ] **Один из главных выводов в переосмыслении концепции** - взаимодействовать с хуками, как с эффектами, которые могут сработать множество раз, и их поведение должно быть идемпотентным. Они должны подготавливать и очищать окружение под себя сами, самостоятельно, и не забывать об этом. **Именно по этой причине, в StrictMode страницы рендерятся дважды,** для проверки хуков на наличие подобных потенциальных ошибок.
    - [ ] В будущем, **подобное переосмысление хуков**, и отношения к ним, позволит добавить новые подходы и фичи в реакте (**Suspense** и восстановление состояний у отключённых хуков)
- [ ] **Хуки** - это отдельные, самостоятельные процессы. При рендеринге - выполняются описанные в реакте инструкции. Инструкции, описанные в теле компонента. По итогу их выполнения формируется результат. **И ТОЛЬКО ПОСЛЕ ВКЛЮЧЕНИЯ ЭТОГО РЕЗУЛЬТАТА В DOM**, начинают своё выполнение хуки. **Т.е.: хуки выполняются ТОЛЬКО после фактически завершённого рендеринга**
- [ ] Каждый хук - отдельный, самостоятельный процесс. Выполняет только то, что должен
- [ ] **Хуки** запускаются после каждого рендера. **Иногда нужно другое поведение. Управлять этим можно через массив зависимостей.**
    - [ ] В зависимостях указываются только **РЕАКТИВНЫЕ (изменяемые) значения**. setSomeState функции хуков, useRef и переменные вне компонента - **не являются реактивными**
- [ ] **В некоторой степени,** можно сказать, что хуки, по своему поведению, эмулируют поведение методов жизненного цикла классовых компонентов **(но это лишь часть действительности).**
    - [ ] **Строго говоря, хуки вообще нельзя считать заменой методов ЖЦ. Хуки - это про другое. Но с некоторыми оговорками можно считать что это альтернатива методам ЖЦ**
    - [ ] **Эффекты запускаются по результату** _**рендеринга.**_ В частности, при (условно) эмуляции метода **componentDidMount** - хук срабатывает и вызывается (и содержимый в нём код) только после того, как страница была смонтирована и внедрена в DOM
        - [ ] **useLayoutEffect - вызывается ДО операции painting. В нём можно размещать логику, которая должна отработать непосредственно между монтированием с последующей вставкой в DOM и её отрисовкой на экране (какое-то изначальное значение/состояние**
        - [ ] **useEffect - вызывается ПОСЛЕ операции painting**
        - [ ] В обоих случах DOM уже сформирован. Он готов, но не покрашен, поскольку не дошла очередь выполнения до задач рендеринга. А значит, можно переписывать и оперировать DOM без вреда в виде повторных рендерингов.
    - [ ] **Эффекты обычно должны синхронизировать ваши компоненты с внешней системой. Если внешней системы нет**, и вы хотите настроить только одно состояние на основе другого состояния, **вам может не понадобиться эффект.**
- [ ] **Хуки, при необходимости,** должны иметь методы очистки (если они подписывались на что-то при запуске). Такими методами очистки могут быть:
    - Отписка от сервера
    - Сброс анимаций
    - Установка флагов для игнорирования результатов ранее запущенных запросов (в самих хуках - отбрасывание результатов запросов)
    - и т.д., любые, которые помогут привести систему в изначальное состояние
- [ ] **Когда хуки НЕ НУЖНЫ?**
    - Для запуска операций при первом запуске - просто запусти в теле компонента **(<App/>)**
    - Для преобразования данных для рендеринга
    - Для обработки пользовательских событий
    - Сохранение результатов вычислений в хуке
    - Сброс внутреннего состояния компонента (когда проблема при перемещении между несколькими одинаковыми компонентами)
    - Настройка состояния в зависимости от пропсов - лишние рендеры. Лучше делать сразу в теле компонента, заворачивая в **if**
    - Для запросов по сети В ПРИНЦИПЕ, можно использовать хуки, если нет альтернативы в виде кешированных хуков или других методов от фреймворка.
- [ ] **useEffect** - состояние
    - [ ] **Всё итак понятно. По этому, ниже только то, что касается переосмысления в подходе работы с ним**
    - [ ] **Выполняется ПОСЛЕ монтирования и отрисовки в DOM-дерево**
    - [ ] Если ваш Эффект извлекает что-то, функция очистки должна либо [прервать выборку](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) , либо проигнорировать ее результат:
    - [ ] **Вы не можете «отменить» сетевой запрос**, который уже был выполнен, **но ваша функция очистки должна гарантировать, что выборка, которая больше не актуальна , не повлияет на ваше приложение**. Если **userId** изменяется с '**Alice'** на '**Bob**', очистка гарантирует, что ответ с данными для '**Alice**' будет проигнорирован, даже если он прибудет после '**Bob**'. Способ поддержки корректности поведения хуков

        ```JavaScript
        useEffect(() => {
          let ignore = false;

          async function startFetching() {
            const json = await fetchTodos(userId);
            if (!ignore) {                           // Отбрасываем результаты
              setTodos(json);
            }
          }

          startFetching();

          return () => {                             // Подготовка состояния перед следующим рендерингом
            ignore = true;
          };
        }, [userId]);
        ```

    - [ ] **useEffect** - в целом, не лучшее место для размещения императивных инструкций. У этого может быть множество негативных последствий
        - [ ] **Эффекты не работают на сервере**
        - [ ] **Выборка непосредственно в Эффектах позволяет легко создавать «сетевые водопады».** Вы визуализируете родительский компонент, он извлекает некоторые данные, визуализирует дочерние компоненты, а затем они начинают извлекать свои данные.
        - [ ] **Извлечение непосредственно в Эффектах обычно означает, что вы не загружаете предварительно и не кэшируете данные.** Например, если компонент размонтируется, а затем снова монтируется, ему придется снова получать данные.
        - [ ] **Это не очень эргономично.** `fetch`При написании вызовов таким образом, чтобы не страдать от ошибок, таких как условия гонки , требуется довольно много шаблонного кода
        - [ ] **Всё выше описанное является проблемами, которые следует избегать. В основном проблема связана с недостаточно корректной обработкой операций. Для этого либо использовать проверенные решения (хуки, кеш-механизмы и запросщики) либо пилить свои (но нужно быть осторожным и внимательным)**
        - [ ] Очистка. При обновления срабатывает перед рендерингом компонента. При удалении компонента - сразу после
    - [ ] Есть ряд событий, которые под категорию **“Эффекты”** не подпадает и, соответственно, не должен обрабатываться как **Эффект, например:**
        - checkAuthToken();
        - loadDataFromLocalStorage();
        - fetch('/api/buy', { method: 'POST' });
    - [ ] **Подготовку данных для компонента** (фильтрация и сортировка) стоит проводить на уровне выше и шарить на все компоненты.
        - [ ] **Или пихать сразу в константу const visibleTodos = getFilteredTodos(todos, filter); А ещё лучше - сразу же, на месте замемоизировать такие вычисления через useMemo**
        - [ ] В случаях, когда нужно сделать что-то только единожды при появлении компонента (получение данных с сервака), либо делать делать через доп переменную-флаг в хуке, либо уже через инстанс в JS классе геттере данных

            ```JavaScript
            let didInit = false;

            function App() {
              useEffect(() => {
                if (!didInit) {
                  didInit = true;
                  // ✅ Only runs once per app load
                  loadDataFromLocalStorage();
                  checkAuthToken();
                }
              }, []);
              // ...
            }

            // Или так

            if (typeof window !== 'undefined') { // Check if we're running in the browser.
               // ✅ Only runs once per app load
              checkAuthToken();
              loadDataFromLocalStorage();
            }

            function App() {
              // ...
            }
            ```

- [ ] **Refs** - Многоцелевой хук
    - [ ] **Позволяет записать в себя и сохранить данные**, и это не стригерит обновление компонента (в отличии от useState).
    - [ ] **Не тригерит обновления,** потому что **представляет собой простой неизменяемый объект**, который хранит значения во внутреннем поле **current**. **Ссылка на объект не меняется - реакт не тригерит обновление**. Причём для этого хука изменения состояния происходят моментально (просто мутация свойства), а не в следующем рендер-цикле
    - [ ] Кстати, не имеет смысла добавлять реф в зависимости useEffect, поскольку ссылка на него никогда не меняется (но если реф передаётся пропсом - надо добавлять, потому что пропс может меняться)

        ```JavaScript
        let ref = useRef(0);

        function handleClick() {
        	ref.current = ref.current + 1;
        	alert('You clicked ' + ref.current + ' times!');
        }

        // Или положить любое другое значение, факт чего не дожен стригерить обновление
        const intervalRef = useRef(null);

        clearInterval(intervalRef.current); // Очитска при перезапуске таймера
        intervalRef.current = setInterval(() => {
          setNow(Date.now());
        }, 10);
        ```

        - [ ] В принципе, можно было бы заменить на изменение нескольких состояния, тем более что все они применятся за один такт, но вариант с рефами более корректен и предсказуем (меньше зависимостей нужно удерживать в голове)
    - [ ] **Позволяет получить и сохранить в себе ссылку на существующий узел в DOM** - (манипуляция DOM)

        ```JavaScript
        function handleClick() {
            inputRef.current.focus();
        }

        <input ref={myRef}> // Это говорит React поместить этот <input>узел DOM в inputRef.current
        ```

    - [ ] **Рефы - как способ синхронизации реакт-компонентов с внешним окружением**. **Можно иметь внешний проигрыватель** (или метрику, или что угодно другое), при манипуляции рект-кнопкой прокидывать реф во внешний не-компонент, и подвзяывать его таким образом к реакт-компоненту, и оказывать через него влияние
    - [ ] **Позволяет сохранить в себе не только ссылки на DOM элементы, но и сами данные. Например, идентификатор счётчика (и потом сразу же вернуть его из эффекта для очистки)**
    - [ ] Изначально, рефы назначаются только текущему компоненту. Так же, можно прокинуть рефы глубже по дереву, но только через forwardRef

        ```JavaScript
        const MyInput = forwardRef((props, ref) => {
        	return <input {...props} ref={ref} />;
        });
        ```

- [ ] **useCallback**
    - [ ] Кеширует функцию (**ссылку на неё**, а не результат её выполнения). Позволяет избегать повторного вычисления описания функции. Определяет функцию при первом рендеринге, и потом всегда возвращает её, если зависимости не изменились.
    - [ ] **const cachedFn = useCallback(fn, dependencies)**
    - [ ] Когда использовать:
        - [ ] В работе с компонентами, хук **useCallback** используется с **React.memo**, позволяя обернуть компонент и всегда передавать ему значение (фукнцию) в виде **неизменяемого пропса**, что позволит не запускать рендер многократно без необходимости. Оборачивая функцию таким **хуком**, **мы гарантируем, что это всегда одна и та же функция, а если так - нет смысла повторно рендерить весь компонент**
        - [ ] **Когда функция, оборачиваемая в колбек, используется в качестве зависимостей для для других хуков.** Если она всегда одна и та же, то нет смысла повторно запускать остальные хуки из-за неё. В т.ч. и все возвращаемые функции из кастомного хука
- [ ] **useLayoutEffect -** почти как useEffect, но срабатывает перед монтированием в DOM
    - [ ] Позволяет сделать какую-то работу непосредственно перед отрисовыванием экрана. Например, чекнуть итоговый макет и, в зависимости от требований, что-то поменять. В итоге - изменения применятся, но не будем миганий и всё будет красиво. Вероятно, работает на микротасках
        - [ ] **Проблема - блокирует рендер. Если какие-то тяжкие вычисления - будет тяжело. Будь аккуратен**
- [ ] **useMemo -** позволяет **кэшировать результат вычислений** между повторными рендерингами.
    - [ ] **Используется именно для кеширования сложных вычислений. Что бы не пересчитывать сложные штуки**
- [ ] **useTransition** — **хук, позволяющий совершить не срочный неблокирующий переход.**
    - [ ] **Цель - пометить указанное изменение состояния как не срочное.**

    Возвращает статус и функцию-обёртку: **[ isPending, setTransition ] = useTransition**

    - **isPending** - флаг состояния перехода
    - **setTransition** - обёртка для включения перехода

    **Самое главное:**

    - **Это изменение состояний вызываемые в обёртке** (если они тяжеловесные), **не блочит интерфейс, и могут быть прерваны другими обычными изменениями состояния**
    - **В будущем, также, будет использоваться при переключении на компонент, который ещё не готов к рендерингу** (**загружаются данные,** или **навигация** внутри приложения, или **другая асинхронщина**). Позволит вызвать переключение на загружаемый контент, и пока он не готов - не блочить интерфейс (альтернатива **Suspense**, когда вместо фолбека позволяет оставить текущий не заблоченный интерфейс, + предоставляя дополнительный флаг состояния перехода). Но это пока эксперименты.
    - **Другими словами:** позволяет оставить интерфейс интерактивным при попытке смены состояний из-за тяжёлых вычислений или другим причинам не готовности компонента. Также, эти переходы можно безболезненно прерывать в процессе самого перехода
    - **setTransition - функция перехода**, которая может быть использована отдельно от хука, вне компонентов (но без **isPending**-флага)

    ---

### Основные поинты и понятия

- [ ] **Concurrency (Параллельный режим работы) - Архитектура Fiber**

    **Concurrency** в контексте React относится к способности библиотеки управлять множественными задачами, которые могут выполняться, прерываться и возобновляться независимо друг от друга. **Это достигается благодаря архитектуре Fiber**, которая позволяет React выполнять работу **асинхронно**:

    - **Прерывание и возобновление работы**: React может начать обновление компонента, прервать его, если появляется более приоритетная задача (например, обработка ввода пользователя), а затем возобновить недавно прерванную работу.
    - **Планирование приоритетов**: React может назначать различные уровни приоритета разным типам обновлений. Это позволяет более важным обновлениям (как анимации) выполняться быстрее, в то время как менее критичные задачи могут быть отложены.

    Раньше это был отдельный экспериментальный режим работы, теперь же это функционирование по дефолту

- [ ] **Fiber (fiber-архитектура)**

    Архитектура Fiber в React действительно позволяет приостанавливать, возобновлять и отменять вычисления благодаря своему гибкому управлению выполнением задач. Это достигается за счет нескольких ключевых механизмов:

    ### **1. Файберы как единицы работы**

    **В архитектуре React Fiber** процесс сохранения прогресса работы при её прерывании осуществляется **с помощью структуры данных**, называемой **"Fiber".**

    Каждый компонент в **React** представлен **файбером**, **который является структурой данных**, содержащей информацию

    - **о компоненте,**
    - **его состоянии, пропсах**
    - **отношениях с другими компонентами**.
    - Текущем состоянии работы над ним

    Это позволяет React работать с каждым компонентом независимо, обрабатывая, приостанавливая или отменяя их обновления по отдельности.

    ### **2. Структура Fiber**

    Каждый узел Fiber содержит множество полей, важных для управления состоянием и выполнением работы:

    - **Child**: ссылка на первый дочерний компонент.
    - **Sibling**: ссылка на следующий соседний компонент.
    - **Return**: ссылка на родительский компонент.
    - **Alternate**: ссылка на альтернативное состояние этого же узла, которое представляет предыдущее или будущее состояние компонента в процессе рендеринга.

    ### **3. Процесс сохранения прогресса**

    В процессе своей работы, построении и обновлении интерфейса, **React** может сохранять результаты свой работы

    1. **Построение или обновление дерева Fiber**: Когда **React** начинает рендеринг компонентов, он строит новое дерево **Fiber** или обновляет существующее. Каждый **Fiber** узел в этом дереве представляет часть пользовательского интерфейса.
    1. **Двойная буферизация**: Ключ к возможности прерывания и возобновления работы заключается в технике двойной буферизации, которая используется в **Fiber**. **Каждый компонент имеет два узла Fiber —**
        1. **current (текущее дерево компонентов)** - отображает состояние компонента, которое в данный момент видит пользователь.
        1. **Work-in-progress (которое используется как черновик для текущей работы - накопления возможных изменений)** - используется для подготовки нового состояния UI.
    1. **Прерывание работы**: Когда происходит прерывание (например, из-за высокоприоритетного события, такого как ввод пользователя), React сохраняет прогресс в **work-in-progress**узле **Fiber**.
        Он знает, до какого компонента добрался в процессе рендеринга и сохраняет всю необходимую информацию в этом узле.

    1. **Возобновление работы**: Когда **React** готов возобновить прерванную работу, он использует информацию, сохраненную в работающих узлах **Fiber**, чтобы продолжить рендеринг с того места, где он остановился, без необходимости пересчитывать уже обработанные компоненты.

    ### **4. Приостановка и возобновление выполнения**

    **Fiber** позволяет React распределять **время выполнения по мере доступности ресурсов браузера**. Используя цикл событий браузера и такие API, как `**requestIdleCallback**`, React может временно прервать выполнение работы над одним компонентом и возобновить его позже, не блокируя основной поток:

    - **Приостановка**: Когда выполнение компонента начинает затягиваться, и приближается обработка других задач или событий, React может приостановить выполнение, сохраняя текущее состояние работы.
    - **Возобновление**: React может возобновить приостановленную работу позже, когда основной поток станет менее загруженным. Это делается с того места, где работа была приостановлена.

    **Как это реализуется технически**

    **React** использует планировщик задач (**Scheduler**), который позволяет управлять приоритетами задач и их исполнением. **Scheduler** рассматривает разные типы задач (например, синхронные, отложенные, анимации) и определяет, какие из них должны быть выполнены сейчас, а какие могут подождать.

    - **requestIdleCallback** и **requestAnimationFrame** часто используются для планирования задач в соответствии с их приоритетом и доступностью ресурсов браузера.

    При получении задач, помеченных как срочные, текущая работа может быть приостановлена, выполнена срочная задача, и уже после, реакт возвращается к оставшимся задачам

    ### **5. Отмена обновлений**

    Fiber также позволяет отменять уже выполненные или частично выполненные вычисления:

    - **Отмена**: Если вычисления или изменения состояния становятся ненужными (например, пользователь переключился с вкладки, на которой шли вычисления), React может отменить эти обновления, **(**просто отбросив **work-in-progress** узел **Fiber)** даже если они уже были частично высчитаны.

    **Как именно происходит отмена обновлений, что экран не дёргается?**

    ### **Как React фактически прерывает работу**

    **Фазы работы**: В React работа разделена на две фазы: фазу рендеринга (**commit phase)** и фазу фиксации **(commit phase)**.

    1. **Фаза рендеринга** (фаза вычислений и расчётов в реакте) — это когда React вычисляет изменения, которые нужно сделать (например, какие компоненты нужно обновить или удалить). Эта фаза может быть прервана и возобновлена без видимых последствий для пользователя, потому что визуальные изменения еще не применяются к **DOM**.
    1. **Фаза фиксации (фаза реальной отрисовки в DOM)** - после того как все необходимые вычисления в фазе **рендеринга** выполнены, начинается фаза фиксации. В этой фазе **React** применяет все изменения к реальному **DOM**. **Эта фаза атомарна и не может быть прервана**, что гарантирует, что все изменения отображаются одновременно, предотвращая мигание или частичные обновления.

    ### **Отбрасывание работы**

    1. **Work-in-Progress Fiber**: Во время фазы рендеринга React работает с так называемым **Work-in-Progress (WIP) деревом**. Это дерево представляет новое состояние интерфейса, которое ещё не было применено. Если процесс работы нужно отбросить (например, из-за изменения приоритетов или поступления новых данных, требующих других изменений), **React** может просто отказаться от текущего **WIP** дерева и начать создание нового на основе последних данных.
    1. **Оптимизация производительности**: Для минимизации затрат на рендеринг и предотвращения ненужных изменений **DOM, React** использует алгоритм сравнения (**reconciliation**), который определяет минимальное количество изменений, необходимых для приведения **DOM** в актуальное состояние.

    ### **Визуальная стабильность**

    1. **Двойная буферизация**: Используя двойную буферизацию (два дерева - две структуры данных, **current и WIP), React** поддерживает текущее и новое состояния компонентов отдельно, так что пользователь никогда не видит промежуточное состояние рендеринга. Изменения становятся видимыми только после завершения фазы фиксации.
    1. **Batching Updates**: React также группирует множество мелких обновлений в одно большое, что сокращает количество операций с DOM и помогает избежать визуального "мигания".

    ### **6. Управление приоритетами**

    **Fiber** умеет различать задачи по уровню их важности (например, анимации или отклики на ввод данных имеют более высокий приоритет, чем обновления фонового процесса). Это позволяет React оптимизировать процесс рендеринга, придавая приоритет задачам, которые наиболее критичны для пользовательского опыта.

- [ ] **Reconciliation (Согласование)**

    **Reconciliation** — процесс сравнения старой версии и новой версии приложения, для обнаружения изменений, и определения того, какие части необходимо отрендерить повторно. **Процесс, который ранее называли виртуальным DOM**

    - **Эффективное сравнение**: React сравнивает предыдущее дерево компонентов (виртуальный DOM) с новым, созданным в результате изменений в компонентах, чтобы определить, какие изменения необходимо применить к реальному DOM.
    - **Минимальное количество операций**: Целью этого процесса является минимизация количества дорогостоящих операций с DOM, что увеличивает производительность интерфейса.
    - [https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-reconciler/src/ReactInternalTypes.js](https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-reconciler/src/ReactInternalTypes.js)
- [ ] **ErrorBoundaries - обработчик ошибок в компонентах React**
    - [ ] ==Проверить на наличие или отсутствие проверки проблем по типу: is not a function, .lenght, is not defined and another==
    - [ ] Компонент-враппер, позволяющий оборачивать части приложения, и отлавливать возникающие в них ошибки.
    - [ ] Предоставляет два метода, один для поимки ошибки, второй для её логирования. Позволяет поймать ошибку, показать вместо упавшего компонента фоллбек, и залогировать ошибку
    - [ ] Реализуется только в виде Классового компонента

    ```JavaScript
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error) {
        // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        // Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
        logErrorToMyService(error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          // Можно отрендерить запасной UI произвольного вида
          return <h1>Что-то пошло не так.</h1>;
        }

        return this.props.children;
      }
    }

    // Дальнейшее использование
    <ErrorBoundary>
      <MyWidget />
    </ErrorBoundary>
    ```

    - [ ] Без его использования, если возникнет ошибка, приложение просто будет размонтировано, и отобразит белый экран
    - [ ] Где он **НЕ СМОЖЕТ** поймать ошибки
        - обработчиках событий ([подробнее](https://ru.legacy.reactjs.org/docs/error-boundaries.html#how-about-event-handlers));
        - асинхронном коде (например колбэках из `setTimeout` или `requestAnimationFrame`);
        - серверном рендеринге (Server-side rendering);
        - самом предохранителе (а не в его дочерних компонентах). Если возникнет в самом себе - ошибка будет всплывать выше
- [ ] **Cерверный рендеринг в реакте из коробки**
    - [ ] В реакте (и ряде других пакетов) есть готовые методы для разработки сайтов с использованием серверного рендеринга. Это всё идёт, что называется “Из коробки”. Другое дело, что реализовать собственную систему с использованием этого - это очень сложно и тяжело и подвержено большому количеству багов и других проблем.
    - [ ] По этому, для реализации серверного рендеринга разрабатываются отдельные фреймворки по типу Next.js, которые берут на себя всё, что связано с серверным рендерингом приложения ==(ЧЕКНУТЬ ДЕЙСТВИТЕЛЬНО ЛИ НЕКСТ ПРЕДЛАГАЕТ ВОЗМОЖНОСТЬ ПОТОКОВОЙ ПЕРЕДАЧИ ХТМЛ СФОРМИРОВАННОЙ СТРАНИЦЫ?)==
- [ ] **Мемоизация (в конспекте)**
    - [ ] **useCallback -** Мемоизация функций (колбеки)
    - [ ] **useMemo -** Мемоизация вычислений
    - [ ] **React.memo -** Мемоизация компонентов
    - [ ] **reSelect** - Мемоизация хуков для стора
- [ ] **Подходы, паттерны и практики в React**
    - [ ] **Container/Presentation** (один поставляет и управляет данными, другой только отображает)
    - [ ] **Compound components** - (select with the options)
    - [ ] **HOC**
    - [ ] **Render-props**
    - [ ] **Composition**
- [x] **Методы (включая классовые, устаревшие) в Реакте**
    - [x] **render()** — единственный обязательный метод в классовом компоненте.
        - [x] При вызове он проверяет **this.props** и **this.state** и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
    - [x] **constructor()** - Конструктор компонента **React** вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(**props**). Если это не сделать, **this.props** не будет определён. Это может привести к багам.
        - [x] Конструкторы в **React** обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта **this.state.** Привязка обработчиков событий к экземпляру.
        - [x] Конструктор — единственное место, где можно напрямую изменять **this.state.** В остальных методах необходимо использовать **this.setState().**
    - [x] **componentDidMount()** - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
        - [x] Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в **componentWillUnmount()**.
    - [x] **componentDidUpdate(prevProps, prevState, snapshot)** - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
    - [x] **componentWillUnmount()** - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    - [x] **shouldComponentUpdate(nextProps, nextState)** - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
    - [x] **static getDerivedStateFromProps(props, state)** - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
        - [x] Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
    - [x] **getSnapshotBeforeUpdate(prevProps, prevState)** - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр **componentDidUpdate().**
    - [x] **static getDerivedStateFromError(error)** - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. **getDerivedStateFromError()** вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в **componentDidCatch().**
    - [x] **componentDidCatch(error, info)** - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.
    - [ ] Хуки и эмуляция методов ЖЦ

        В функциональных компонентах вместо методов жизненного цикла используются хуки, которые представляют собой функции-обработчики, вызываемые React в процессе жизненного цикла компонента. **ХОТЯ ИХ НЕЛЬЗЯ СЧИТАТЬ альтернативой методам ЖЦ классовых компонентов, но приближенно они соответствуют так:** Вот альтернативы для каждого метода жизненного цикла классовых компонент:

        1. **constructor** - нет прямой альтернативы в функциональных компонентах. Вместо этого используйте хук **useState** или **useRef** для инициализации состояния или ссылок.
        1. **componentWillMount** - нет прямой альтернативы в функциональных компонентах. Вместо этого используйте хук **useEffect** с пустым массивом зависимостей.
        1. **componentWillReceiveProps** - вместо этого используйте хук **useEffect** для отслеживания изменений пропсов.
        1. **componentWillUpdate** - вместо этого используйте хук **useEffect** для выполнения побочных эффектов перед обновлением компонента.
        1. **getDerivedStateFromProps** - вместо этого используйте хук **useEffect** для получения нового состояния на основе измененных пропсов.
        1. **shouldComponentUpdate** - вместо этого используйте хук **useMemo** или **React.memo** для оптимизации повторного рендеринга компонента.
        1. **render** - нет прямой альтернативы в функциональных компонентах, так как это основная функция, возвращающая элементы.
        1. **setState** - вместо этого используйте хук **useState** или **useReducer** для изменения состояния функционального компонента.

---

## NEXT.js (изучить)

- [ ] Виды и типы серверного рендеринга
- [ ] Гидратация и дегидротация кода
- [ ] Как работает код при рендере на серваке? Запоминается ли состояние хуков? Или всё отрабатывает на сервере, а потом сбрасывается и повторно запускается на фронте?
- [ ] Потоковый серверный рендеринг, что это такое и как работает
- [ ] Стор заполняется или нет
- [ ] Разобраться в различных подходах и сценариях работы, Серверная генерация и всё такое. Какие есть варианты, как оно всё работает
- [ ] Прочитать статью о флеш-вспышках при генерации и гидратации сайта после ССР
- [ ] В принципе всю доку перечитать
- [ ] Какая последовательность выполнения? Сперва гидратация а потом вызов useEffect? Или наоборот? Может вместо useEffect использовать useLayoutEffect? Что бы точно ничего не мерцало и не рендерилось повторно?

## JavaScript (классы изучить и перенести)

- [ ] Классы
    - [ ] Прототипное наследование - [https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co](https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co)
    - [ ] Протекторы классов. Как описываются, как работают и работают ли вообще. Смысл и предназначение
    - [x] Как встраиваются методы в классах. Почему одни методы имеют одну ссылку, а другие разную? Стрелочные и анонимные функции.
        - [x] Потому что в классах могут быть только методы. Они добавляются в прототип класса. А свойства могут быть только у экземпляра класса
    - [x] Методы
    - [x] Геттеры и сеттеры
    - [x] Синтаксический сахар, и почему классы - это **НЕ** только сахар
        - [x] Да, есть причины, по которым `class` можно считать синтаксическим сахаром - это связано с механизмом того, как определяются классы, и что по факту это функции-конструкторы. Но, это не совсем верно. Это не только сахар, потому что:
            - [x] Во-первых, функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[IsClassConstructor]]: true`. Поэтому это не совсем то же самое, что создавать её вручную.
            - [x] В отличие от обычных функций, конструктор класса не может быть вызван без `new`
            - [x] Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
            - [x] Методы класса являются неперечислимыми. Определение класса устанавливает флаг `enumerable` в `false` для всех методов в `"prototype"`. И это хорошо, так как если мы проходимся циклом `for..in` по объекту, то обычно мы не хотим при этом получать методы класса.
            - [x] Классы всегда используют `use strict`. Весь код внутри класса автоматически находится в строгом режиме.
            - [x] Также в дополнение к основной, описанной выше, функциональности, синтаксис `class` даёт ряд других интересных возможностей
            - [x] Они поддерживают статические методы и свойства, которые не привязаны к экземплярам класса и могут быть использованы напрямую на самом классе. Что позволяет более удобно организовать данные, и методы работы с этими данными (инкапсуляцию)
    - [x] Переопределение методов и свойств класса
    - [x] Метод Super
    - [x] This в классах
    - [x] Инверсия зависимости, и переприсваивание метода одного класса к другому
    - [x] Контекст исполнения для классов

## JavaScript

- [x] Нововведения из стандартов
    - [x] ES6 - [https://frontend-stuff.com/blog/es6/](https://frontend-stuff.com/blog/es6/) [https://habr.com/ru/post/305900/](https://habr.com/ru/post/305900/)
    - [x] ES7 - [https://frontend-stuff.com/blog/es2016/](https://frontend-stuff.com/blog/es2016/)
    - [x] ES8 - [https://frontend-stuff.com/blog/es2017/](https://frontend-stuff.com/blog/es2017/)
    - [x] ES9 - [https://frontend-stuff.com/blog/es2018/](https://frontend-stuff.com/blog/es2018/)
    - [x] ES10 - [https://frontend-stuff.com/blog/es2019/](https://frontend-stuff.com/blog/es2019/)
    - [x] ES11 - [https://frontend-stuff.com/blog/es2020/](https://frontend-stuff.com/blog/es2020/)
    - [x] ES12 - [https://frontend-stuff.com/blog/es2021/](https://frontend-stuff.com/blog/es2021/)
- [x] This

    ![[Untitled 1.png]]

    - [x] Перечислить все варианты вызова функции, где this указывает на разные
        объекты.

        - [x] Обычный вызов через (): в нестрогом режиме this === window, в строгом
            this === undefined.

        - [x] Вызов в контексте объекта (dot notation): в данном случае, this === объект, в контексте
            которого была вызвана функция.

        - [x] Вызов через call и apply: в данном случае, this === аргумент, который
            передали первым в call или apply.

        - [x] Вызов после применения bind: в данном случае, this является тем, что
            было переданно в качестве аргумента в функцию bind.

        - [x] Вызов с оператором new: в данном случае, this является пустым объектом
            с прототипом, указанным у функции-конструктора.

- [ ] Классы
    - [ ] Прототипное наследование - [https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co](https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co)
    - [ ] Протекторы классов. Как описываются, как работают и работают ли вообще. Смысл и предназначение
    - [x] Как встраиваются методы в классах. Почему одни методы имеют одну ссылку, а другие разную? Стрелочные и анонимные функции.
        - [x] Потому что в классах могут быть только методы. Они добавляются в прототип класса. А свойства могут быть только у экземпляра класса
    - [x] Методы
    - [x] Геттеры и сеттеры
    - [x] Синтаксический сахар, и почему классы - это **НЕ** только сахар
        - [x] Да, есть причины, по которым `class` можно считать синтаксическим сахаром - это связано с механизмом того, как определяются классы, и что по факту это функции-конструкторы. Но, это не совсем верно. Это не только сахар, потому что:
            - [x] Во-первых, функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[IsClassConstructor]]: true`. Поэтому это не совсем то же самое, что создавать её вручную.
            - [x] В отличие от обычных функций, конструктор класса не может быть вызван без `new`
            - [x] Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
            - [x] Методы класса являются неперечислимыми. Определение класса устанавливает флаг `enumerable` в `false` для всех методов в `"prototype"`. И это хорошо, так как если мы проходимся циклом `for..in` по объекту, то обычно мы не хотим при этом получать методы класса.
            - [x] Классы всегда используют `use strict`. Весь код внутри класса автоматически находится в строгом режиме.
            - [x] Также в дополнение к основной, описанной выше, функциональности, синтаксис `class` даёт ряд других интересных возможностей
            - [x] Они поддерживают статические методы и свойства, которые не привязаны к экземплярам класса и могут быть использованы напрямую на самом классе. Что позволяет более удобно организовать данные, и методы работы с этими данными (инкапсуляцию)
    - [x] Переопределение методов и свойств класса
    - [x] Метод Super
    - [x] This в классах
    - [x] Инверсия зависимости, и переприсваивание метода одного класса к другому
    - [x] Контект исполнения для классов
- [x] Детали
    - [x] Движок языка в целом
    - [x] Замыкания. Тема на понимание внутренних механизмов, способов решений несколько
        - 1 [https://habr.com/ru/company/ruvds/blog/340194/](https://habr.com/ru/company/ruvds/blog/340194/)
        - 2 Пример

            ```Plain
            const arr = [10, 12, 15, 21];
            arr.forEach(function (item, i) {
                setTimeout(function () {
                    console.log('Index: ' + i + ', element: ' + item);
                });
            });
            ```

        - 3 [https://ru.stackoverflow.com/questions/433887/Почему-асинхронная-функция-внутри-цикла-выполняет-последнюю-итерацию-много-раз/433888#433888](https://ru.stackoverflow.com/questions/433887/%d0%9f%d0%be%d1%87%d0%b5%d0%bc%d1%83-%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f-%d0%b2%d0%bd%d1%83%d1%82%d1%80%d0%b8-%d1%86%d0%b8%d0%ba%d0%bb%d0%b0-%d0%b2%d1%8b%d0%bf%d0%be%d0%bb%d0%bd%d1%8f%d0%b5%d1%82-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d0%bd%d1%8e%d1%8e-%d0%b8%d1%82%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d1%8e-%d0%bc%d0%bd%d0%be%d0%b3%d0%be-%d1%80%d0%b0%d0%b7/433888#433888)
        - Замыкания в классах

            class Counter {
            constructor() {
            let count = 0;
            this.increment = function() {
            count++;
            console.log(count);
            };
            }
            }

            const myCounter = new Counter();
            myCounter.increment(); // 1
            myCounter.increment(); // 2

- [x] Внутренности
    - [x] Внутренние механизмы повторить (движок)
        - [x] **Всего движков, по сути, осталось 3.** Принцип их внутренней работы - это различные комбинации компиляторов с различными оптимизациями (иногда без них). Как они работают - отдельный вопрос но, в целом, при непосредственной разработке на это можно не опираться
    - [x] This, контекст, различные способы применения контекста
        - [x] В JavaScript есть четыре способа вызова функции: **как метод** объекта, **как функция**, **как конструктор** и **через методы** `**apply**` **и** `**call**`. В каждом из этих случаев значение `**this**` будет определено по-разному.
        - [x] При вызове функции как метода объекта, `**this**` ссылается на объект, к которому относится метод. Если функция вызывается как обычная функция, `**this**` ссылается на глобальный объект `**window**` или `**undefined**` в строгом режиме. Если функция вызывается как конструктор с помощью ключевого слова `**new**`, `**this**` ссылается на новый экземпляр объекта. Если методы `**apply**` или `**call**` используются для вызова функции, то значение `**this**` определяется переданным в них первым аргументом.
        - [x] Что такое связывание в JS (позднее связывание)
            - [x] **Связывание (binding) в JavaScript относится к процессу определения значения** `**this**` **во время выполнения функции.** Позднее связывание (late binding) означает, что значение `**this**` определяется во время выполнения функции, в зависимости от того, как функция вызывается. Это означает, что значение `**this**` не определяется в момент определения функции, а в момент ее вызова. Это позволяет использовать одну и ту же функцию в разных контекстах, обрабатывать события и создавать функции-обертки.
    - [x] Стрелочные функции
- [x] **Приведение типов**
- [x] **Как работает конкатенация строк**
- [x] **Работа метода reduce**
- [x] **Каррирование** `**console.log(add_v1(2)(5)(7)());**` **(это является преднастройкой функции?)**
    - [x] Да, это можно назвать преднастройкой функции
    - [x] **Каррирование - это техника функционального программирования, которая заключается в преобразовании функции с несколькими аргументами в последовательность функций с одним аргументом.**
- [x] Базовые вещи языка
    - [x] Методы slice, splice, reduce, foreach, shift, unshift и прочее. **ВСЕ** основные методы для задач под собесы
        - [x] `**slice**`: возвращает выбранные элементы массива в новом массиве.
        - [x] `**splice**`: изменяет содержимое массива, удаляя или заменяя существующие элементы и/или добавляя новые.
        - [x] `**reduce**`: применяет функцию-аккумулятор к каждому элементу массива слева направо, возвращая одно результирующее значение.
        - [x] `**forEach**`: выполняет указанную функцию один раз для каждого элемента в массиве.
        - [x] `**shift**`: удаляет первый элемент из массива и возвращает его значение.
        - [x] `**unshift**`: добавляет один или более элементов в начало массива и возвращает новую длину массива.
- [x] Асинхронность
    - [ ] Хотите практический пример? Попробуйте ответить на вопрос - возможно ли при помощи try catch перехватить exception в промисах. Если да, опишите в общих чертах как это происходит.
    - [ ] что происходит с текущим выполняемым кодом, когда он встречает вызов метода await? Он извлекается из стека вызова? Или как? Как там вообще дальше всё работает внутри движка?
    - [x] Все виды асинхронщины, включая колбеки и другие подходы
        - [x] Порядок выполнения асинхронных задач всех видов. **Весь асинхронный код делится на несколько типов -**
            - [x] **псевдоасинхронный - синхронный (колбеки),**
            - [x] **микротаски - промисы,**
            - [x] **макротаски - таймауты.**
            - [x] **requestAnimationFrame (rAF)** - своя отдельная очередь. Позволяет выполнить JavaScript-код прямо перед обновлением интерфейса. Задачи из очереди выполняются один раз перед обновлением интерфейса в порядке их добавления.

                **Основная задача requestAnimationFrame — это плавное выполнение JavaScript-анимаций,** но используют его нечасто, так как анимации проще и эффективнее задать средствами CSS.

            - [x] **requestIdleCallback (rIC / очередь простоя браузера) - добавляет задачи в ещё одну (четвёртую) очередь, которая будет выполняться в период простоя браузера, когда нет более приоритетных задач из других очередей.** Выполняется в момент, когда браузер свободен. В хроме ограничено 50 мс на таску. Если дольше - таска прерывается, и повторно автоматом не перезапускается. Нужно быть осторожным. **В качестве второго аргумента можно указать timeout** и, если задача не будет выполнена в течение указанного числа миллисекунд, **то она добавится в обычную очередь, после чего выполнится в порядке общей очереди. НЕ ПОДДЕРЖИВАЕТСЯ В САФАРИ**
            - [x] **Веб-воркер (Web Worker)** - это механизм браузера, который позволяет выполнять JavaScript-скрипты в фоновом потоке, отдельном от основного потока выполнения. Используются для выполнения тяжелых вычислений, которые могут замедлить работу основного потока выполнения, таких как обработка больших объемов данных, сложные алгоритмы и т.д. **Веб-воркеры могут создаваться и управляться из основного потока выполнения с помощью JavaScript API.** Они могут обмениваться данными с основным потоком выполнения **с помощью механизма сообщений.**

                **Веб-воркер работает отдельно, и независимо**

        - [x] Порядок выполнения асинхронного кода
            - [x] **Псевдоасинхронный - синхронный (колбеки)** - выполняются с блокировкой колстека
            - [x] **Микротаски - промисы -** выполняются все, пока очередь не опустеет (сколько бы это ни заняло времени). При появлении новых тасок в процессе выполнения существующих - они добавятся в очередь, и будут выполнятся все, до опустошения очереди
            - [x] **Макротаски (таймауты)** - Из **очереди задач** движок выполняет, как правило, одно или несколько заданий, **стараясь уложиться в 16,6 миллисекунды.** Как только пройдёт отведённое время, движок пойдёт обновлять интерфейс, даже если в очереди остались задачи. К ним он вернётся на следующем витке цикла событий.
            - [x] **requestAnimation** выполнит все задачи из своей очереди, потому что он гарантирует выполнение кода перед обновлением интерфейса. Но если в ходе выполнения кто-то добавит новые задания в очередь, то они выполнятся уже на следующем витке.
            - [x] **requestIdleCallback** - в моменты, когда все задачи завершены, и очереди пусты, будут выполнены задачи из очереди простоя браузера
    - [x] **Промисы. Promise**
        - [x] Порешать задачи на промисы
        - [x] Соревнование промисов. Выполнение коллекции промисов. **Есть несколько вариантов пакетной обработки промисов. Надо читать отдельно**
        - [x] Отлавливание ошибок
            - [x] синхронных
            - [x] Асинхронных
            - [x] Что там с вложенным скрытым трайкетчем?
            - [x] Метод finally получит ошибку (или положительный результат) при выполнении промиса? Она долетит до него?
        - [x] Чейнинг обработки в промисах. Через кетч и через трай кетч. Что там за невидимый трай кетч. **Конспект**
        - [x] Почему работает чейнинг методов в then? **Каждый обработчик самостоятельно возврашает новый промис с данными от предыдущего обработчика. Данные из обработчика автоматически оборачиваются в промис. Благодаря этому можно пилить бесконечную цепочку обработчиков**
        - [x] Каким образом они могут завершиться и прерваться чейнинг? Из них возвращаются промисы? **Прямо прервать чейнинг - нельзя. Можно только завалить промис выкинув ошибку или зареджектить, тогда выполнение перескочит на ближайший catch в цепочке (если такой есть)**
            - [x] Они сами возвращают данные? Или нет? А если не вернуть из одного в другой? **Возвращать надо явно. Руками через return или если вызываемый вложенный промис сам возвращает данные. Если ничего не вернуть явно - будет передан undefined**
                - [x] Ошибку? Через троу или можно через реджект? **Можно и так и так выкинуть ошибку промисе и в его обработчиках**
            - [x] А после catch можно использовать then? А там внутри только возврат новых значений, или можно резолвить? **Использовать можно. Можно вернуть из кетч, и использовать дальше. Можно возвращать новое. Как угодно**
        - [x] Корректный чейнинг. Что после чего будет выполняться, а что нет. **Вся цепочка выполнится. даже если куча обработчиков последовательно ничего не передают друг другу. Пропускаются только те обработчики, которые скипаются от момента ошибки и до ближайшего catch**
        - [x] Какие методы после каких можно описывать, а какие нет. **Описывать можно любые после любых, в каком угодно порядке. Даже then после finally. finally прозрачен для данных. Он не принимает и не возвращает никаких значений. Следующий за ним в цепочке обработчик будет брать данные не от него, а от обработчика до него**
        - [x] Как передать значение из одного в следущий. **Простым return. Он сам его в промис обернёт. Ну или можно сразу промис возвратить, хуже не будет**
        - [x] Почему у then обработчика есть вариант с двумя аргументами? **- Хз, просто ради удобства, других причин не нашёл**
        - [x] **ПРОМИСЫ - как устроены, и за счёт чего работают**
            1. Использование **async** делает функцию **асинхронной**, и автоматически возвращает из неё **промис**. Даже если просто написать **return 1 - всё равно** вернётся промис со значением **1**
            1. Такая асинхронная функция может останавливать своё выполнение на моменте вызова **await** перед очередным асинхронным кодом внутри.
            1. Это означает, что выполнение кода внутри этой функции фактически приостанавливается. Да, это так - выполнение приостанавливается. Реализовано это за счёт генераторов.
            1. Код самой функции приостанавливает своё выполнение. Извлекается из стека выполнения (КУДА ИЗВЛЕКАЕТСЯ?), стек доступен для другого синхронного кода, синхронный код выполняется, заканчивает своё выполнение, если к этому моменту разрезолвился асинхронный вызов внутри приостановленной функции, то эта функция повторно помещается в стек вызова и происходит её дальнейшее исполнение
            1. Каким образом она приостанавливает своё выполнение? При встрече **await**, выполнение приостанавливается, функция запоминает своё внутреннее состояние, **ВЫКИДЫВАЕТСЯ КУДА-ТО вовне (веб-АПИ)**, там продолжает своё фоновое исполнение. Продолжается выполнение остального кода в стеке.
            1. Далее, в момент резолва кода после **await**, эта функция помещается в очередь **микротасок**, и от туда попадает снова в стек вызова. Разворачивает своё последнее состояние, и продолжает своё выполнение с последнего места
            1. Как и где сохраняется состояние асинхронной функции-генератора?

                Когда генератор приостанавливает свое выполнение, он добавляется в очередь **микрозадач (microtask queue)**, а не в очередь **макрозадач (macrotask queue).**

                Это происходит потому, что генератор, созданный внутри функции с ключевым словом **async**, возвращает **промис**, который разрешается только после того, как генератор завершит свою работу. Внутри генератора могут быть другие **await** операторы, которые также создают **микрозадачи**.

                Они работают на генераторах

            1. Генераторы - Особого вида функции, которые могут в итеративной форме вызываться и каждый раз возвращать новое, очередное значение. При выполнении, генераторы могут приостанавливать своё исполнение, и возобновлять его спустя время

                При приостановке своего исполнения, данные о функции сохраняются в специальном объекте генераторе, а после, эти данные используются для восстановления окружения при продолжении работы генератора (но как и где тогда сохраняются данные о лексическом окружении?)

- [x] Найти ответ от нейронки по поводу объяснения механизма работы евентлупа
- [x] Задача про Вызов сеттаймаут 0, и тут же вызов резолве промис. В обоих прокидывается просто функция, и вопрос что какая из них быстрее выполнится
- [x] Задачи
    - [x] Замыкание
        - [x] Проблема в том, что асинхронный setTimeout выводит значения используя замыкание. Проблема в том, что когда выполнение доходит до точки обращения к внешней переменной - она уже имеет одно единственное, не сменяемое значение. Фиксить это можно:
            - [x] Через доп аругмент в сетТаймаут: **setTimeout(function (i) {console.log(i);}, 100, i); -** передаёт этот аргумент в вызываемую функцию (и тогда это каждый раз новое значение)
            - [x] Через байнд
            - [x] Через использование let, потому что тогда на каждую итерацию создаётся новый контекст исполнения

                ```JavaScript
                for (var i = 0; i < 10; i++) {

                	setTimeout(function (i) {
                		console.log(i);
                	}, 100, i);

                }

                for (let i = 0; i < 10; i++) {
                	const t = i

                	setTimeout( () => {
                		console.log(t);
                	}, 100);
                }
                ```

## TypeScript

## Алгоритмы

## GIT

## Пример аналитики по фронту

## **Процесс аналитики для фронта, как процесс:**

1. **Выработать сам процесс аналитики сервисов для фронтендеров**
    1. **Сформировать +-стандартный (типовой) дизайн-документ, как шаблон для описания аналитики по отдельному фрагменту (странице/блоку/фиче)**
        1. Важное: понять цель и потребность от аналитики по фронтовой части
            1. Что хочет аналитик
            1. Что фронтендер
            1. Побочные потребности у бизнеса
        1. Сформировать наиболее полный пример отдельного раздела, включая примеры ссылок на DTO, API, другие разделы с описанием фичей, ФТ и прочее
        1. Накинуть другим фронтам, пообсуждать, кто как видит, кому чего не хватает в примере, кто бы чем бы хотел дополнить. У кого какой опыт
        1. **Что должно быть**
            1. Основная шаблонная инфа (типа хедера страницы)
            1. Мета (описательные вещи, без непосредственно относящегося к самому рассматриваемого компоненту)
            1. Скрин (обязательно), намного облегчит жизнь.
                1. Обновляются редко, если что - обновится. А сам скрин в аналитике - своеобразное версионирование - описана именно эта версия макета, без привязки к веткам и прочему.
                1. Если это фича, поведение, что-то ещё, без интерфейсное (например, как формируются правила отображения кнопок) - скрин не нужен.
            1. Отдельный лист ссылок на описание включённых в текущий компонент дочерних элементов: для страницы это фичи и блоки. Можно прямо делить на типы описаний, что это - **pages, widget, feature, entity. Думаю, стандартизировать это будет норм идеей**
                1. Описать это в виде перечня в таблице, в начале или конце
                1. Ссылаться на них по ходу описания страницы
        1. **Как должно быть**
            1. Понятно и просто
            1. Неочевидные вещи - **надо расписывать**
            1. Очевидные - **не надо расписывать**
            1. Если что-то может изменятся, выполнять функционал, зависеть от чего-то - **надо расписывать что и как, в деталях. Описывать от чего и как зависит.**
                1. Если зависит от того, что уже детально и понятно расписано ранее (например, от ролевой модели, от статусной, от прав, принципала, авторизации и прочего) - писать коротко: **“Зависит от ХХХ + ссылка на описанное”**
                1. Если зависит от специфичных вещей, и ранее не было описано (как кнопка Подписать при создании документа) - описать по месту, детально: **“Делает то-то и то-то, показывается тогда-то и тогда-то, меняется при условии….”**
            1. Переиспользуемый функционал можно описать заранее отдельно, и потом ссылаться на него по месту в тексте. Например:
                1. Описывается функционал редактирования, создания, удаления, пересылки, экспорта документа, включая (АПИ, ДТО, зависимости и всё что нужно) для каждого функционала отдельно, например в разделе функциональных возможностей. Далее, ссылаться на них. Пример:
                1. Форма редактирования документа. Кнопки Создать, Сохранить, Удалить, по тексту не расписываются, а помечаются ссылками на их детальное описание.
                    1. Исключения: Если функционал этих кнопок отличается от базового для данного случая использования, и просто сослаться будет недостаточно. Просто понятно описать как удобнее
        1. **Чего не должно быть / не нужно**
            1. Очевидные вещи расписывать детально не нужно. Лишний текст в доке - это лишний текст в доке, который протухнет
            1. Избегать копипасты в тех случаях, когда точно такое же описано в других местах как самостоятельный блок/обоснование/поведение
            1. Акцентировать какой компонент чем является, только если важно (что ссылка, что кнопка, а что просто лейбл похожий на кнопку или инпут). В других случаях, не нужно описывать что и чем является. Это лишнее
    1. **Договориться о шаблоне для ведения аналитики по фронтовой части**
    1. **Создать пример, желательно потяжелее, как готовый пример реализации**
    1. **Создать и описать несколько страниц подобным образом**
1. **Пошарить готовый вариант (с примерами) между всеми аналитиками на НВБО, и принять за стандарт описания**
    1. Оставить раздел с примерами, с наполенными шаблонами, как референс
    1. Показать и предложить работу на НВБО по такому подходу
    1. Порешать проблемки возникающие при этом
1. Утвердить и юзать везде и всеми

==Красным== - важные вещи, которые хочет подсветить аналитик

==Жёлтым== - мои комменты в шаблоне для аналитика ==(поясняю что я имел ввиду там). В артефакте аналитики их не должно быть==

---

# **Топик:** Страница просмотра исходящего письма

**Макет:** _<ссылка на макет>_ ==(на макет в фигме)==

**Тип:** фича / страница / раздел / ==(что мы тут описываем - страницу или какой-то блок)==

**Назначение:** Просмотр документа ==(смысл этого блока в приложении)==

![[Untitled 2 2.png|Untitled 2 2.png]]

## **Пример аналитики для фронтенда**

## **Общее описание:** ==(прим. к шаблону: тут можно детально описать что, зачем, для чего и как работает)==

- Страница просмотра письма. Позволяет просмотреть данные по письму, его содержимому, прикреплённым файлам, и предоставляет возможность выполнения одиночных действий над документом.
- Отображает полный набор данных о документе
- ==Просмотр только исходящего письма==
- Можно просмотреть документ во всех статусах, ==кроме “удалён”==

## Составные части, функционал и поведение ==(прим. к шаблону: описание важных отдельных деталей)==

**Хлебные крошки** - для возврата на предыдущую страницу

**Блок с заголовком страницы** - содержит тему письма + бейджик со статусом письма

**Блок с табами** на форме просмотра

- **Каждая вкладка** - отдельный раздел с данными о документе
- **Текущая вкладка** - “Информация”. Содержит основной набор данных о документе в виде сообщения

**Блок с данными о письме -** системная информация (продукт, услуга, компания-контрагент, номер документа, время получения) о письме. Данные извлекаются из самого письма

**Блок с аттачментами** - файлы, приложенные к письму. Можно скачать по отдельности на ПК пользователя. ==(прим. к шаблону: описывать детали - какие поля за что отвечают, что происходит при наведении -== ==**не нужно**====. Это очевидно, и это переиспользуемый компонент из кита)==

**Тело письма** - сам контент из письма

**Доступно выполнение основных и второстепенных действий**

- **Второстепенные** действия:
    - _**Копировать**_ - переход на форму создания нового документа. Форма заполняется данными из того документа, с которого перешли ==(прим. к шаблону: в принципе, ссылка здесь уже избыточна, и так понятно)==
    - _**Редактировать**_ - переход на форму редактирования документа
    - _**Удалить**_ - открывается модальное окно с вопросом “_Вы уверены, что хотите удалить сообщение?” <ссылка на модалку в макетах>_. При подтверждении - вызов АПИ метода удаления документа _<ссылка на метод удаления документа>_,
    - ==Кнопки вариативны==, состав кнопок зависит от статуса документа _<ссылка на статусную модель>_, права УЛ _<ссылка на описание ролевой и прав пользователя>,_
    - ==(прим. к шаблону: если тут подразумевается какая-то сложная или специфичная логика, то можно описывать поведение и варианты на этой странице, помимо ссылок указанных выше)==
- **Основные**: Подписание, Подписание и отправка.
    - Вариативны, состав кнопок зависит от статуса документа _<ссылка на статусную модель>_, права пользователя _<ссылка на описание ролевой и прав пользователя>_, право подписания УЛ _<ссылка на ролевую на клиенте>_
    - ==Требует== на клиенте расширенной логики для определения логики того, какие из кнопок отображать
    - ==(прим. к шаблону: если тут подразумевается какая-то сложная или специфичная логика, описывать либо тут, либо на другой странице, как было бы более логично описывать)==

## Вариации отображения

==(прим. к шаблону: если блок/страницы изменяется, то эту разницу можно описать здесь, с указанием причин различия. Если различий не много - описать лучше здесь, если различий много или сложный механизм отличий - лучше вынести в отдельный артефакт аналитики с описанием нового варианта)==

- В зависимости от статуса документа
    - Драфт - просмотр драфта
    - Новый - просмотр нового
    - На подписании - просмотр на подписании
- В зависимости от прав УЛ
    - Драфт - просмотр драфта
    - Новый - просмотр нового
    - На подписании - просмотр на подписании

## **Дополнительный функционал и поведение на странице**

==(прим. к шаблону: остальные важные вещи, не попадающие в основные блоки)==

- Страница периодически запрашивает обновление о документе. Если письмо изменилось, форма просмотра документа обновится и отобразит последние актуальные данные о письме
- Если кем-то другим будет удалён документ, и при очередном фоновом просмотре документа будет получен документ в статусе “Удалён” - ==редиректнуть пользователя на фолбек-ошибку с компонентом “Документ не может быть просмотрен”==

## Референсы==**(**====прим. к шаблону:== ==**указывается, если есть на что ссылаться. Можно включать то, что напрямую в тексте не описано, но есть на макете)**==

**Таблица 1 - Компоненты страницы**

|   |   |   |   |
|---|---|---|---|
|Блок / компонент|Краткое описание|Ссылка на описание блока|Вариативен на странице|
|Табы в хедере блока|Табы со страницами прсомотра доп контента по документу|хххххххх|-|
|Блок второстепенных действий с документами|Блок со второстепенными действиями над документом.|- Копировать документ - ххх  <br>- Редактировать документ - ххх  <br>- Удалить документ - ххх|+|
|Блок с данными о письме|Содержит данные о продукте, услуге и прочей мете|ххххх|-|

### Git Flow

![[Untitled 3.png]]

![[Untitled 4.png]]

![[Untitled 5.png]]

![[Untitled 6.png]]

![[Untitled 7.png]]

![[Untitled 8.png]]

![[Untitled 9.png]]

![[Untitled 10.png]]

![[Untitled 11.png]]

![[Untitled 12.png]]

![[Untitled 13.png]]

![[Untitled 14.png]]

[[Пример-предложение аналитики для фронта (1)]]
